Need tips on how to prioritize and schedule a bunch of work items
project-management scheduling
It took me some time, but I've finally managed to write down all the tasks that need to go into Version 1.0 of the software product I'm working on. 
The list is almost 1000 items long.
We are a 3-person team, and we've somehow managed to get this far using MindMeister, Google Docs, @todos in the code etc. Now, I have everything neatly grouped by feature, but how do I prioritize all this and turn it into a schedule?
Any advice would be greatly appreciated - I'm not looking for software recommendations, however - I'm seeking advice on how to take this enormous bag of tasks - ranging from bug-fixes to application modules - and find out in what order I should do them.


My recommended approach will be based on Agile methodology best practices...
So, you have what in Agile terms is called a "backlog" defined- that's great - and an important first step.
A good Agile pace that is commonly used is a 2-3 week iteration length...and at the end you have a set of releasable features.  This will establish the "heartbeat" of your development process. Next, you'll decided how to organize and group the features into Stories and Tasks.
You'll want to grow the underlying architecture and let it naturally emerge based on the ordering of the Stories and Tasks that you select from your backlog.
Its important to mitigate risks early - so you'll want to select early those items that are either performance or implementation unknowns that might pose the largest risk - and could result in the largest rework impact.  For example - establishing the messaging infrastructure - might be an early architectural feature that might be included if you select a Story that required a persistent message to be delivered to complete a unit of work.
Can you group the set of features into functional categories that might naturally evolve to describe the 1.0 release as a System of Systems?  For example, the Administrative functions, the User Profile Management, Reporting, external integration layers, Database Access Objects, etc.
What are the simplest Story / Use Cases that you can write - that will map to some of the ~1,000 features / requirements you've defined?  Select a set of Stories (or individual Tasks from a Story - if the Story itself is too large to implement in a single interation).  It will take some additional effort - but recomposing your requirements into a set of Stories/Tasks is important.
You'll find that you will refactor during subsequent interations - but that your steady 2-week heartbeat iteration schedule will keep delivering real functionality.
At various points you may want to schedule an architecture iteration just to focus on some cleaning-up / refactoring - and that's ok too.

Prioritize ruthlessly.  1000 action items is a lot, and the odds are that as you go you'll modify some, toss others, and add new ones.  Your list will not survive the things you learn by actually building the software, and if you don't do the most important stuff first, you'll end up with a mess.
For every item or feature, you have to answer the question:  Can the product be at all usable or useful without this?  If yes, it can wait; everything else goes to the head of the queue.
After that, I like to group milestones by focus:  I'll do a features milestone (or multiple ones if there are natural small clusters of features), a UI milestone where I'll focus on AJAX/rich client interactivity, a performance milestone where I profile and do database & server tuning, etc.  Or break them up some other way - but definitely break them up.  Work in smaller bites with specific focus for each iteration, and make sure each iteration is solid before moving on.

Since you are indicating that all these items are required, I will assume that there is not much chance of dropping items off the list (at least for now).  Given that, you have 2 large tasks at hand - deciding when to do items, and determining how long it will take to do them.
Since you have already conveniently grouped the items by feature, I would start by prioritizing the features.  Hopefully this will significantly reduce your working set, and allow you to actually get through it in a reasonable amount of time.
I would prioritize each feature based on its risk.  Some things are easy to implement and others are difficult.  Since they are all required, do the riskiest features first, when your schedule is more flexible to meet any unanticipated problems.  Wait until the end of your cycle, and Murphy's law will strike you down.  
Given your small team, I would just send the list of features around and ask everyone to mark it if they consider it a risky or difficult feature to implement.  Add up all the marks and you have your "risk assessment", with the highest scoring items getting assigned first.  
Alternatively, if you have easy access to your customer, ask them to rate the "risk" associated with each feature (in this case risk refers to the worst-case scenario of not having the feature - if not having something would be annoying, it is not risky.  If not having the feature would result in them not using your product, it is high-risk).
Now that you have a priority queue, it is time to estimate.  For the initial estimates, I would simply do an order of magnitude estimate for each of the features.  Since it sounds as if you have already broken the features up, you should be able to get a decent feel for whether something is going to take hours, days or weeks.  From the sounds of it, you are still early in development, so I don't believe there is much point in trying to get an accurate estimate on something that won't be implemented for another month or so.
As you pull items off your queue, have your team provide more accurate estimates by identifying granular tasks that shouldn't take more than a few hours.  If you want to refine your order of magnitude estimates, you can progressively provide quick estimates for the remaining tasks based on your up-to-date knowledge of the system.
This should provide you with a fairly accurate short term schedule, and a fuzzier long term schedule that will progressively get more accurate.
Finally, if you are facing a long development cycle, I would recommend you identify certain target goals or dates, and when you meet those goals, sit down and repeat this whole process.  I would never go longer than 2 weeks without revisiting these things.  New items will get added, others will get overtaken and become obsolete, and others will become higher risk as you better understand the problem.  All of this must be taken into account.
