Correct behavior for interface methods that can't be implemented
java
If I have a class that needs to implement an interface but one or more of the methods on that interface don't make sense in the context of this particular class, what should I do?
For example, lets say I'm implementing an adapter pattern where I want to create a wrapper class that implements java.util.Map by wrapping some immutable object and exposing it's data as key/value pairs.  In this case the methods put and putAll don't make sense as I have no way to modify the underlying object.  So the question is what should those methods do?


Any method that cannot be implemented according to the semantics of the interface should throw an UnsupportedOperationException.

That depends on your business case.  2 options:

Do nothing.
Throw an UnsupportedOperationException.

Use whichever makes more sense.  If you do nothing, you are not obeying the contract of the interface.  However, throwing a runtime exception can wreak havoc on the calling code.  Thus, the decision will have to be made based on how you will be using the class.  Another option would be to use a simpler or different interface, if possible.
Do note that the Java library goes the exception route in the specific case of read-only collections.

It was noted below that UnsupportedOperationException is a part of the java collections framework.  If your situation is outside of collections, and the semantics bother you, you can roll your own NotImplementedException, or if you are already using commons-lang, you could use theirs.

Your two choices are really only:

Do nothing.
Throw an exception.

Both have disadvantages. In the first case, by having an empty method, you could mislead the programmer into thinking something happened to your data. The second case breaks the whole idea of polymorphism inherent in interfaces.

Note that UnsupportedOperationException is only OK because of the particular property of the Java Collections Framework, that implementations are permitted to "goof off" implementing part of the interface because they're immutable.
So it's fine for put() (assuming all the mutator methods do the same thing), but a Map which throws UnsupportedOperationException from the size() method would just be broken. If you're trying to implement a kind of map which doesn't know how big it is, you may be in trouble (although sometimes you can return Integer.MAX_VALUE).
Also note that the class documentation for UnsupportedOperationException says that it is part of the Java Collections Framework. Outside the collections framework, throwing UnsupportedOperationException is not be expected and could lead to client code that plain doesn't work. Sure, it's a RuntimeException, but just because you can throw it doesn't mean that your method will work if it always does.
Instead you could either refactor the interface (perhaps splitting it in two), or else rethink why this class is claiming to be a Foo when it plainly isn't, since it can't do the things that Foos are defined to be able to do.

That read-only collection already provided by Java throw the UnsupportedOperationException during write operations is already an unfortunate design hack.  The collection classes should have been written with separate read-only and write-only interfaces that are both inherited by the full read-write interface.  Then you know what you're getting.
