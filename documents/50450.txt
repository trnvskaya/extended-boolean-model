How to iterate a jagged array?
vb.net arrays jagged-arrays
This has been driving me crazy for a few days.  Why doesn't the following work?

    Dim arr(3, 3) As Integer

    For y As Integer = 0 To arr.GetLength(0) - 1
        For x As Integer = 0 To arr.GetLength(y) - 1
            arr(y, x) = y + x
        Next
    Next


Also, what if the array looked like this instead?
{ {1, 2, 3},
  {4, 5, 6, 7, 8, 9, 9, 9},
  {5, 4, 3, 2}
}



arr.GetLength(y)
should be
arr.GetLength(1)

Because there is no '2' or '3' dimension.  Should be .GetLength(1) instead of .GetLength(y)
Also:  in VB.Net array declarations work a little differently.  The subscript you specify in the declaration is the last index, not the number of items created like with C# or C++.   But the array is still 0-indexed like C# or C++, instead of 1-indexed like VB6.  That means that if you move to VB.Net from a different language your array instincts are probably wrong, no matter which language it is.  In VB.Net, Dim arr(3,3) As Integer actually creates a 4x4 array. 

Well what if I had an array that looked like this
{ {1, 2, 3},
  {4, 5, 6, 7, 8, 9, 9, 9},
  {5, 4, 3, 2}
}

How would GetLength(1) still know the length of each row?

Basically what I want is.... a way to find the number of elements in any given row.  

Your declaration: DIM arr(3,3) As Integer allready specifies that there are 3 elements in any given row (or 4, I'm not so sure about VB)
You could try:
Dim arr(3) as Integer()

You should then be able to do:
arr(n).Length

To find the length of row n.
I'm a bit rusty on VB6 and never learned VB.NET, but this should give you a 'jagged' array. Check out the msdn documentation on multidimensioned arrays.

Dim arr(3, 3) As Integer
Dim y As Integer
Dim x As Integer

For x = 0 To arr.Rank - 1
    For y = 0 To arr.GetLength(x) - 2
        arr(x, y) = x + y
    Next
Next

The above code worked for me. 
Edit, the code feels dirty though.  I'm wondering what it is you are trying to accomplish?  

Ok, so what you really need is a "jagged array". This will allow you to have an "array that contains other arrays of varying lengths".
  Dim arr As Integer()() = {New Integer() {1, 2, 3}, New Integer() {4, 5, 6, 7, 8, 9, 9, 9}, New Integer() {5, 4, 3, 2}}

  For x = 0 To arr.GetUpperBound(0)
      Console.WriteLine("Row " & x & " has " & arr(x).GetUpperBound(0) & " columns")
      For y = 0 To arr(x).GetUpperBound(0)
          Console.WriteLine("(" & x & "," & y & ") = " & arr(x)(y))
      Next
   Next

Output: 
Row 0 has 2 columns
(0,0) = 1
(0,1) = 2
(0,2) = 3
Row 1 has 7 columns
(1,0) = 4
(1,1) = 5
(1,2) = 6
(1,3) = 7
(1,4) = 8
(1,5) = 9
(1,6) = 9
(1,7) = 9
Row 2 has 3 columns
(2,0) = 5
(2,1) = 4
(2,2) = 3
(2,3) = 2


This code en C# is to get all the combinations of items in a jagged array:
    static void Main(string[] args)
    {
        bool exit = false;
        int[] indices = new int[3] { 0, 0, 0 };
        string[][] vectores = new string[3][];

        vectores[0] = new string[] { "A", "B", "C" };
        vectores[1] = new string[] { "A", "B" };
        vectores[2] = new string[] { "B", "D", "E", "F" };

        string[] item;
        int[] tamaÃ±os = new int[3]{vectores[0].GetUpperBound(0), 
            vectores[1].GetUpperBound(0), 
            vectores[2].GetUpperBound(0)};

        while (!exit)
        {
            item = new string[]{ vectores[0][indices[0]],
                    vectores[1][indices[1]],
                    vectores[2][indices[2]]};

            Console.WriteLine("[{0},{1},{2}]={3}{4}{5}", indices[0], indices[1], indices[2], item[0], item[1], item[2]);
            GetVector(tamaÃ±os, ref indices, ref exit);
        }
        Console.ReadKey();
    }

    public static void GetVector(int[] tamaÃ±os, ref int[] indices, ref bool exit)
    {
        for (int i = tamaÃ±os.GetUpperBound(0); i >= 0; i--)
        {
            if (tamaÃ±os[i] > indices[i])
            {
                indices[i]++;
                break;
            }
            else
            {
                //ULTIMO ITEM EN EL ARRAY, VALIDAR LAS OTRAS DIMENSIONES SI YA ESTA EN EL ULTIMO ITEM
                if (!ValidateIndexes(tamaÃ±os, indices))
                    indices[i] = 0;
                else
                {
                    exit = true;
                    break;
                }
            }
        }
    }

    public static bool ValidateIndexes(int[] tamaÃ±os, int[] indices)
    {
        for (int i = 0; i < tamaÃ±os.Length; i++)
        {
            if (tamaÃ±os[i] != indices[i])
                return false;
        }
        return true;
    }

The output looks like
[0,0,0]=AAB
[0,0,1]=AAD
[0,0,2]=AAE
[0,0,3]=AAF
[0,1,0]=ABB
[0,1,1]=ABD
[0,1,2]=ABE
[0,1,3]=ABF
[1,0,0]=BAB
[1,0,1]=BAD
[1,0,2]=BAE
[1,0,3]=BAF
[1,1,0]=BBB
[1,1,1]=BBD
[1,1,2]=BBE
[1,1,3]=BBF
[2,0,0]=CAB
[2,0,1]=CAD
[2,0,2]=CAE
[2,0,3]=CAF
[2,1,0]=CBB
[2,1,1]=CBD
[2,1,2]=CBE
[2,1,3]=CBF
