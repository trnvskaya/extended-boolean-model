Should one use < or <= in a for loop
performance conventions readability
If you had to iterate through a loop 7 times, would you use:
for (int i = 0; i < 7; i++)

or:
for (int i = 0; i <= 6; i++)

There are two considerations:

performance
readability 

For performance I'm assuming Java or C#.  Does it matter if "less than" or "less than or equal to" is used?  If you have insight for a different language, please indicate which.
For readability I'm assuming 0-based arrays.
UPD: My mention of 0-based arrays may have confused things. I'm not talking about iterating through array elements.  Just a general loop. 
There is a good point below about using a constant to which would explain what this magic number is. So if I had "int NUMBER_OF_THINGS = 7" then "i <= NUMBER_OF_THINGS - 1" would look weird, wouldn't it. 


It makes no effective difference when it comes to performance. Therefore I would use whichever is easier to understand in the context of the problem you are solving.

Both of those loops iterate 7 times.  I'd say the one with a 7 in it is more readable/clearer, unless you have a really good reason for the other.

In Java 1.5 you can just do
for (int i: myArray) {
    ...
}

so for the array case you don't need to worry.

I always use < array.length because it's easier to read than <= array.length-1.
also having < 7 and given that you know it's starting with a 0 index it should be intuitive that the number is the number of iterations.

I don't think there is a performance difference.  The second form is definitely more readable though, you don't have to mentally subtract one to find the last iteration number.
EDIT: I see others disagree.  For me personally, I like to see the actual index numbers in the loop structure.  Maybe it's because it's more reminiscent of Perl's 0..6 syntax, which I know is equivalent to (0,1,2,3,4,5,6).  If I see a 7, I have to check the operator next to it to see that, in fact, index 7 is never reached.

I prefer:
for (int i = 0; i < 7; i++)

I think that translates more readily to "iterating through a loop 7 times".
I'm not sure about the performance implications - I suspect any differences would get compiled away.

The first is more idiomatic. In particular, it indicates (in a 0-based sense) the number of iterations. When using something 1-based (e.g. JDBC, IIRC) I might be tempted to use <=. So:
for (int i=0; i < count; i++) // For 0-based APIs

for (int i=1; i <= count; i++) // For 1-based APIs

I would expect the performance difference to be insignificantly small in real-world code.

I think either are OK, but when you've chosen, stick to one or the other. If you're used to using <=, then try not to use < and vice versa. 
I prefer <=, but in situations where you're working with indexes which start at zero, I'd probably try and use <. It's all personal preference though. 

Seen from an optimizing viewpoint it doesn't matter.
Seen from a code style viewpoint I prefer < . Reason:
for ( int i = 0; i < array.size(); i++ )

is so much more readable than
for ( int i = 0; i <= array.size() -1; i++ )

also < gives you the number of iterations straight away.
Another vote for < is that you might prevent a lot of accidental off-by-one mistakes.

I agree with the crowd saying that the 7 makes sense in this case, but I would add that in the case where the 6 is important, say you want to make clear you're only acting on objects up to the 6th index, then the <= is better since it makes the 6 easier to see.

Way back in college, I remember something about these two operations being similar in compute time on the CPU. Of course, we're talking down at the assembly level.
However, if you're talking C# or Java, I really don't think one is going to be a speed boost over the other, The few nanoseconds you gain are most likely not worth any confusion you introduce.
Personally, I would author the code that makes sense from a business implementation standpoint, and make sure it's easy to read.

I'd say use the "< 7" version because that's what the majority of people will read - so if people are skim reading your code, they might interpret it wrongly.
I wouldn't worry about whether "<" is quicker than "<=", just go for readability.
If you do want to go for a speed increase, consider the following:
for (int i = 0; i < this->GetCount(); i++)
{
  // Do something
}

To increase performance you can slightly rearrange it to:
const int count = this->GetCount();
for (int i = 0; i < count; ++i)
{
  // Do something
}

Notice the removal of GetCount() from the loop (because that will be queried in every loop) and the change of "i++" to "++i".

Strictly from a logical point of view, you have to think that < count would be more efficient than <= count for the exact reason that <= will be testing for equality as well.

As a slight aside, when looping through an array or other collection in .Net, I find
foreach (string item in myarray)
{
    System.Console.WriteLine(item);
}

to be more readable than the numeric for loop. This of course assumes that the actual counter Int itself isn't used in the loop code. I do not know if there is a performance change.

There are many good reasons for writing i<7. Having the number 7 in a loop that iterates 7 times is good. The performance is effectively identical. Almost everybody writes i<7. If you're writing for readability, use the form that everyone will recognise instantly.

I remember from my days when we did 8086 Assembly at college it was more performant to do:
for (int i = 6; i > -1; i--)

as there was a JNS operation that means Jump if No Sign. Using this meant that there was no memory lookup after each cycle to get the comparison value and no compare either. These days most compilers optimize register usage so the memory thing is no longer important, but you still get an un-required compare.
By the way putting 7 or 6 in your loop is introducing a "magic number". For better readability you should use a constant with an Intent Revealing Name. Like this:
const int NUMBER_OF_CARS = 7;
for (int i = 0; i < NUMBER_OF_CARS; i++)

EDIT: People arenât getting the assembly thing so a fuller example is obviously required:
If we do for (i = 0; i <= 10; i++) you need to do this:
    mov esi, 0
loopStartLabel:
                ; Do some stuff
    inc esi
                ; Note cmp command on next line
    cmp esi, 10
    jle exitLoopLabel
    jmp loopStartLabel
exitLoopLabel:

If we do for (int i = 10; i > -1; i--) then you can get away with this:
    mov esi, 10
loopStartLabel:
                ; Do some stuff
    dec esi
                ; Note no cmp command on next line
    jns exitLoopLabel
    jmp loopStartLabel
exitLoopLabel:

I just checked and Microsoft's C++ compiler does not do this optimization, but it does if you do:
for (int i = 10; i >= 0; i--) 

So the moral is if you are using Microsoft C++â , and ascending or descending makes no difference, to get a quick loop you should use:
for (int i = 10; i >= 0; i--)

rather than either of these:
for (int i = 10; i > -1; i--)
for (int i = 0; i <= 10; i++)

But frankly getting the readability of "for (int i = 0; i <= 10; i++)" is normally far more important than missing one processor command.
â  Other compilers may do different things.

I have always preferred:
for ( int count = 7 ; count > 0 ; -- count )


It should not be difference in perfomance at least with the x86 compilers. JL and JLE works the same time, as soon as I know. And as for redability, using "<7" for an array of seven elements makes sense.

I follow the first method as that idiom is repeated frequently.
for (int index = 0; index < array.length; i++)
String s = oldString.substring(0, numChars);
etc.  
I'm used to the upper bound being excluded, and would prefer to keep it that way unless there is good reason to change it. (example -- 1 based indexing)

Go for readability first, optimize later (although, quite honestly, I can't imagine any difference that would be noticeable).
Be aware that the 0 -> K form is a C idiom carried over into C# by having arrays be 0 based.  Follow the idiom and don't violate the principal of least astonishment.

You could also use != instead. That way, you'll get an infinite loop if you make an error in initialization, causing the error to be noticed earlier and any problems it causes to be limitted to getting stuck in the loop (rather than having a problem much later and not finding it).

First, don't use 6 or 7.
Better to use:
int numberOfDays = 7;
for (int day = 0; day < numberOfDays ; day++){

}

In this case it's better than using
for (int day = 0; day <= numberOfDays  - 1; day++){

}

Even better (Java / C#):
for(int day = 0; day < dayArray.Length; i++){

}

And even better (C#)
foreach (int day in days){// day : days in Java

}

The reverse loop is indeed faster but since it's harder to read (if not by you by other programmers), it's better to avoid in. Especially in C#, Java...

Making a habit of using < will make it consistent for both you and the reader when you are iterating through an array.  It will be simpler for everyone to have a standard convention.  And if you're using a language with 0-based arrays, then < is the convention.
This almost certainly matters more than any performance difference between < and <=.  Aim for functionality and readability first, then optimize.
Another note is that it would be better to be in the habit of doing ++i rather than i++, since fetch and increment requires a temporary and increment and fetch does not.  For integers, your compiler will probably optimize the temporary away, but if your iterating type is more complex, it might not be able to.

Don't use magic numbers.
Why is it 7? ( or 6 for that matter).
use the correct symbol for the number you want to use...
In which case I think it is better to use
for ( int i = 0; i < array.size(); i++ )


In C++, I prefer using !=, which is usable with all STL containers. Not all STL container iterators are less-than comparable.

The '<' and '<=' operators are exactly the same performance cost.
The '<' operator is a standard and easier to read in a zero-based loop.
Using ++i instead of i++ improves performance in C++, but not in C# - I don't know about Java.

I prefer this:
for (int i = 0; i < 7; i++)

However (this is merely a thought), the readability of it might have to do whether or not arrays are 0-based (C#, Java) or 1-based (VB .NET). I say this because when you work with 0-based arrays, you get in a mindset that 0-6 would run 7 times. I think 0-6 is more intuitive than 1-7. Then again, I come from a C++, Java, C# background.

For some languages/technologies like .NET using .Size or .Length or size()/length() is a bad idea is it accesses that property each time it iterates, so assigned it to a variable has a slightly less performance hit.

As people have observed, there is no difference in either of the two alternatives you mentioned.  Just to confirm this, I did some simple benchmarking in JavaScript.
You can see the results here.  What is not clear from this is that if I swap the position of the 1st and 2nd tests, the results for those 2 tests swap, this is clearly a memory issue.  However the 3rd test, one where I reverse the order of the iteration is clearly faster.

@Chris, Your statement about .Length being costly in .NET is actually untrue and in the case of simple types the exact opposite.
int len = somearray.Length;
for(i = 0; i < len; i++)
{
  somearray[i].something();
}

is actually slower than
for(i = 0; i < somearray.Length; i++)
{
  somearray[i].something();
}

The later is a case that is optimized by the runtime. Since the runtime can guarantee i is a valid index into the array no bounds checks are done. In the former, the runtime can't guarantee that i wasn't modified prior to the loop and forces bounds checks on the array for every index lookup.

As everybody says, it is customary to use 0-indexed iterators even for things outside of arrays.  If everything begins at 0 and ends at n-1, and lower-bounds are always <= and upper-bounds are always <, there's that much less thinking that you have to do when reviewing the code.

The results doesn't make sense.
From a hardware point of view, <= with a loopNuumber-1 will introduce one extra calculation to do loopNumber-1 per iteration. So I assume that < will take less time, if not same amount of time than <=

This falls directly under the category of "Making Wrong Code Look Wrong".  
In zero-based indexing languages, such as Java or C# people are accustomed to variations on the index < count condition.  Thus, leveraging this defacto convention would make off-by-one errors more obvious.
Regarding performance: any good compiler worth its memory footprint should render such as a non-issue.

Edsger Dijkstra wrote an article on this back in 1982 where he argues for lower <= i < upper:

There is a smallest natural number. Exclusion of the lower bound âas in b) and d)â forces for a subsequence starting at the smallest natural number the lower bound as mentioned into the realm of the unnatural numbers. That is ugly, so for the lower bound we prefer the â¤ as in a) and c). Consider now the subsequences starting at the smallest natural number: inclusion of the upper bound would then force the latter to be unnatural by the time the sequence has shrunk to the empty one. That is ugly, so for the upper bound we prefer < as in a) and d). We conclude that convention a) is to be preferred.


Premature optimization is the root of all evil.  Go with readability unless there is a really good reason to worry about < over <=.

No speed difference, but < is more likely to be correct in a language with 0-based arrays. Also, if you want to iterate down instead of up, you can say:
for (i = 7; --i >= 0; ) ...


I would argue it should be <. 
Why use many words when a few will do. One test is easier to understand then two. Consquently, it is easier to unit test and modify going forward. 
Is the difference small? Yes. But why add any complexity when it is not warranted. 
Finally, you are not reliant on any optimizer or implementation of an interpreter when the code is optimized to begin with. To quote Einstein, "keep it as simple as possible but no simpler".

Great question. My answer: use type A ('<')

You clearly see how many iterations you have (7). 
The difference between two endpoints is the width of the range
Less characters makes it more readable
You more often have the total number of elements i < strlen(s) rather than the index of the last element so uniformity is important.

Another problem is with this whole construct. i appears 3 times in it, so it can be mistyped. The for-loop construct says how to do instead of what to do. I suggest adopting this:
BOOST_FOREACH(i, IntegerInterval(0,7))
This is more clear, compiles to exaclty the same asm instructions, etc. Ask me for the code of IntegerInterval if you like. 

So many answers ... but I believe I have something to add.
My preference is for the literal numbers to clearly show what values "i" will take in the loop. So in the case of iterating though a zero-based array:
for (int i = 0; i <= array.Length - 1; ++i)
And if you're just looping, not iterating through an array, counting from 1 to 7 is pretty intuitive:
for (int i = 1; i <= 7; ++i)
Readability trumps performance until you profile it, as you probably don't know what the compiler or runtime is going to do with your code until then.
