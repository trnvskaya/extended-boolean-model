What is the difference between Ruby and Python versions of"self"?
python ruby language-features
I've done some Python but have just now starting to use Ruby
I could use a good explanation of the difference between "self" in these two languages.  
Obvious on first glance:
Self is not a keyword in Python, but there is a "self-like" value no matter what you call it.
Python methods receive self as an explicit argument, whereas Ruby does not.
Ruby sometimes has methods explicitly defined as part of self using dot notation.
Initial Googling reveals
http://rubylearning.com/satishtalim/ruby_self.html
http://www.ibiblio.org/g2swap/byteofpython/read/self.html 


Well, I don't know much about Ruby. But the obvious point about Python's "self" is that it's not a "keyword" ...it's just the name of an argument that's sent to your method.
You can use any name you like for this argument. "Self" is just a convention.
For example :
class X :
    def __init__(a,val) :
        a.x = val
    def p(b) :
        print b.x

x = X(6)
x.p()

Prints the number 6 on the terminal. In the constructor the self object is actually called a. But in the p() method, it's called b.
Update : In October 2008, Guido pointed out that having an explicit self was also necessary to allow Python decorators to be general enough to work on pure functions, methods or classmethods : http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html

self is used only as a convention, you can use spam, bacon or sausage instead of self and get the same result. It's just the first argument passed to bound methods. But stick to using self as it will confuse others and some editors.

Python is designed to support more than just object-oriented programming. Preserving the same interface between methods and functions lets the two styles interoperate more cleanly.
Ruby was built from the ground up to be object-oriented. Even the literals are objects (evaluate 1.class and you get Fixnum). The language was built such that self is a reserved keyword that returns the current instance wherever you are.
If you're inside an instance method of one of your class, self is a reference to said instance. 
If you're in the definition of the class itself (not in a method), self is the class itself:
class C
  puts "I am a #{self}"
  def instance_method
    puts 'instance_method'
  end
  def self.class_method
    puts 'class_method'
  end
end

At class definition time, 'I am a C' will be printed.
The straight 'def' defines an instance method, whereas the 'def self.xxx' defines a class method.
c=C.new

c.instance_method
#=> instance_method
C.class_method
#=> class_method


Despite webmat's claim, Guido wrote that explicit self is "not an implementation hack -- it is a semantic device".

The reason for explicit self in method
  definition signatures is semantic
  consistency. If you write
class C: def foo(self, x, y): ...
This really is the same as writing
class C: pass
def foo(self, x, y): ... C.foo = foo

This was an intentional design decision, not a result of introducing OO behaviour at a latter date.
Everything in Python -is- an object, including literals.
See also Why must 'self' be used explicitly in method definitions and calls?
