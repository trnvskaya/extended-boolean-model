Is there a human readable programming language?
nlp grammar
I mean, is there a coded language with human style coding?
For example:
Create an object called MyVar and initialize it to 10;
Take MyVar and call MyMethod() with parameters. . .

I know it's not so useful, but it can be interesting to create such a grammar.


Perl, some people claim.
print "hello!" and open my $File, '<', $path or die "Couldn't open the file after saying hello!";


AppleScript is pretty close to that, though that is obviously platform dependent.
Here's a script for opening iTunes and playing a playlist
tell application "iTunes"
    activate
    play playlist "Party Shuffle"
end tell

Source: AppleScript Examples

COBOL is a lot like that.
SET MYVAR TO 10.
EXECUTE MYMETHOD with 10, MYVAR.

Another sample from Wikipedia:
ADD YEARS TO AGE.
MULTIPLY PRICE BY QUANTITY GIVING COST.
SUBTRACT DISCOUNT FROM COST GIVING FINAL-COST.

Oddly enough though, despite its design to be readable as English, most programmers completely undermined this with bizarre naming conventions:
SET VAR_00_MYVAR_PIC99 TO 10.
EXECUTE PROC_10_MYMETHOD with 10, VAR_00_MYVAR_PIC99.


Applescript:
tell application "Finder"
 set the percent_free to Â¬
 (((the free space of the startup disk) / (the capacity of the startup disk)) * 100) div 1
end tell
if the percent_free is less than 10 then
 tell application (path to frontmost application as text)
 display dialog "The startup disk has only " & the percent_free & Â¬
 " percent of its capacity available." & return & return & Â¬
 "Should this script continue?" with icon 1
 end tell
end if


VB is as close as I can think of one:
If MyLife.Sucks Then MyLife.End Else MyLife.Continue

Do a google search for "natural language programming" and you'll find lots of information (including why this is a bad idea).

Visual Basic (and BASIC based languages in general) are about as close to human language as you get. I'd argue Python comes pretty close too. Using these you can makes your code read as structed english if you care enough, but no, there's no natural English compilers because there's just too much ambiguity there.

Cobol was kind of like that.

Yes.  It's called COBOL, and people generally detest it.

Basic was a first approach in that direction, and as has been shown in another reply, Perl also allows code that's fairly close to human language - if you ignore all that punctuation.
I just read a very interesting article on how to translate Latin to Perl (for which there's also a Perl module).
So if the human language has enough structure, and you introduce enough restrictions to avoid ambiguousness, you can indeed program in (mostly) human language.
But really nobody really does, because it's very verbose, and hard to make both readable and accurate.

COBOL was intended to be read by managers, and has "noise words" to make it more readable.
The funny thing is, it reads a bit like a verbose DSL.

How about LOLCODE?
HAI
CAN HAS STDIO?
VISIBLE "HAI WORLD!"
KTHXBYE

Simplicity itself!

Why would you do that? It's machine-unfriendly to our R2D2 in the brain, which reads the code to us.

IMHO, human readability is pretty subjective. However, if you want to learn more I would suggest exploring the following topics:

Python - which uses prefers whitespace to 'special characters' (such as { & } for syntax).
Smalltalk - which allows arguments to be spread through the method name.
Ruby
Fluent APIs / Domain specific languages


Having a programming language read like a (verbose) normal language, would be like requiring people to converse all the time in legalese.  All the extra verbiage just gets in the way.
An ideal programming language should have syntax that is as transparent as possible and let the concepts behind the program stand out.  Obviously there is a trade off between having a quick learning curve and having minimal but obscure syntax (think Perl, or even K).

By creating a set of rules, it is possible to do logic programming in Prolog like this.  You can build a grammar (or download one) for a particular domain, create a knowledge base and then query it.  After defining your grammar you could do something like:
bob is a parent of tim.
mary is a parent of bob.

?- X is a grandparent of tim.
X = mary

?- jim is a parent of bob.
false


All languages are 'human readable'. :) How else would someone be able to create it? That being said, languages that support DSLs can be incredibly intuitive such as Boo.

This was "the next big thing" around about the early 1980s and I spent much of my first couple of years as a a coder working in "NATURAL", which was the supposedly the best of the new crop of 4GLs (fourth generation languages) which were designed to make data access (in this case to an ADABAS database) human readable.
Of course it did absolutely nothing of the type.  All we ended up with was verbose badly structured code.  Both of these products are still around, but you've never heard of them, which sort of proves the what a dead end it was.
Actually at that period there appeared to be a general desire to move beyond 'programming' into some sort of 2001 inspired AI heaven.  Oracle were really keen on code generation and I remember with some interest a product called 'the last one' that was being marketed to managers as a product that would automatically generate any program you wanted and make all your programming staff redundant.  Seems not to have lived up to expectations ;-)
It's worth remembering to that SQL was originally marketed in some quarters as a way to allow management to directly query their data.  I was even sent on a course to learn basic SQL (in a large national transport organization that ran on rails - the steel variety) where junior management types were included because they had plans to put basic query tools in their hands.  What a disaster that was.
Maybe it might be different in 50 years, but at the current stage of play coding demands a certain clarity of thought and implementation which is best mediated through a dedicated syntax designed for those ends, not any approximation to a natural language which is unclear and ambiguous.  The nearest approximation is possibly physics where the essence of the subject is in the mathematics used (think a programming language for physics) not verbose wordage. 
ADDED
I was forgetting, apart from COBOL there was also PL/1, sometime credited with allowing NASA to put a man on the moon it was just as verbose as COBOL and tried even harder to be 'Manager-readable'.  Which is why no-one has really heard of it now either :-)

I can read C. That means it's human-readable(because I'm a human). It's just too terse for the average person. The general concept of programming languages is to maximize the information about how the computer should operate in a given line.
This is why Ruby is so popular; it maximizes the functionality in minimal text. English(or any other other natural language) is a pretty imprecise, low-information/character language.
In sum, it is: (i)done before and (ii)a known weaker idea. 

Clarity of Expression is important.
But Clarity of Thought is far, far more important.

Inform 7
Inform 7 is perhaps the language I feel is most appropriately designed in a human language fashion. It is quite application specific for writing adventure games.
It is based on rule-based semantics, where you write a lot defining rules describing the relationship between objects and their location. For instance, the section below is an Inform 7 program:

    "Hello World" by I.F. Author

    The story headline is "An Interactive Example".

    The Living Room is a room. "A comfortably furnished living room."
    The Kitchen is north of the Living Room.
    The Front Door is south of the Living Room.
    The Front Door is a door. The Front Door is closed. The Front Door is locked.

    The insurance salesman is a man in the Living Room. 
    "An insurance salesman in a tacky polyester suit. He seems eager to speak to you." 
    Understand "man" as the insurance salesman.

    A briefcase is carried by the insurance salesman.
    The description is "A slightly worn, black briefcase."
    Understand "case" as the briefcase.

    The insurance paperwork is in the briefcase.
    The description is "Page after page of small legalese." Understand "papers"
    or "documents" or "forms" as the paperwork.

    Instead of listening to the insurance salesman:
        say "The salesman bores you with a discussion of life insurance policies. From his briefcase he pulls some paperwork which he hands to you.";
        move the insurance paperwork to the player.


Example cited from WikiPedia
http://en.wikipedia.org/wiki/Inform

Inform 7 is the most successful such system I've seen. It has two advantages over the cruder systems listed in other answers here: it's for a domain particularly appropriate for natural language (interactive fiction), and it does a fancier analysis of the input code based on more computational-linguistics lore, not just a conventional programming-language grammar that happens to use English words instead of braces, etc.

While not a programming language itself, the parsimonious XML shorthand language (PXSL) makes XSL a hell of a lot more human-readable (and less verbose!) than it arguably already is:
 <doc keywords="x y z">          doc -keywords=<<x y z>>
  <title/>                        title
  <body id="db13">                body -id=db13
    This is text.                   <<This is text.>>
  </body>
</doc>


This is actually a hot topic.
For starters - What is Human readable?
A Chinese-reader cannot read Russian and vice versa. 
It you narrow your domain for example to Chinese pharmacists writing a perscription you could design a language around that. And that would be human readable.
Such as language would fall under a the umbrella of Domain Specific Languages.

HyperTalk and its descendant AppleScript were designed to be similar to the English language.

Chef! Anyone can read recipes right? Behold hello world!
Ingredients.
72 g haricot beans
101 eggs
108 g lard
111 cups oil
32 zucchinis
119 ml water
114 g red salmon
100 g dijon mustard
33 potatoes

Method.
Put potatoes into the mixing bowl. Put dijon mustard into the mixing bowl. 
Put lard into the mixing bowl. Put red salmon into the mixing bowl. Put oil into the mixing bowl. 
Put water into the mixing bowl. Put zucchinis into the mixing bowl. Put oil into the mixing bowl. 
Put lard into the mixing bowl. Put lard into the mixing bowl. Put eggs into the mixing bowl. 
Put haricot beans into the mixing bowl. Liquefy contents of the mixing bowl. 
Pour contents of the mixing bowl into the baking dish.

Sorry if it's not a serious answer, but this is way awesome. :-)

I agree with the general consensus here. "Human readable" general purpose programming languages are mostly a bad idea, but human readable Domain Specific Languages are very worthwhile.
REBOL has a great system for creating DSLs.

I see the Shakespeare programming language have yet to be mentioned.
These programs are coded to look like shakespear plays, the individial characters in the play being variables that can hold numbers and the various phrases in the play manipulate the characters and the number they hold. For instance, "Speak your mind" orders a character to output his value.

I think the two constructs have very different purposes. Natural language has a very loose structure that is subject to interpretation and presumes the existence of a high-level inference engine to understand it -- and it is expected that it will be interpreted incorrectly a good portion of the time! Programming languages are meant to be precise, unambiguous specifications that leave little if anything open to interpretation.
Given that you'd think that using natural language as a programming construct should be a simple matter of taming its variability and clarifying its meaning. But once you've done that you're left with the semantics of a programming language, regardless of how it is syntactically wrapped and packaged.

Sure, Erlang.
-module(listsort).
-export([by_length/1]).

 by_length(Lists) ->
    F = fun(A,B) when is_list(A), is_list(B) ->
            length(A) < length(B)
        end,
    qsort(Lists, F).

 qsort([], _)-> [];
 qsort([Pivot|Rest], Smaller) ->
     qsort([ X || X <- Rest, Smaller(X,Pivot)], Smaller)
     ++ [Pivot] ++
     qsort([ Y ||Y <- Rest, not(Smaller(Y, Pivot))], Smaller).

I'm a human, it's a programming language, and I can read it. I don't know what any of it means, but I see a lot of English words in there, I think.
(Tongue firmly in cheek.)

DSLs can be very natural-looking. See this example created with MGrammar:
test "Searching google for watin"
    goto "http://www.google.se"
    type "watin" into "q"
    click "btnG"
    assert that text "WatiN Home" exists
    assert that element "res" exists
end


That has to be whitespace. The only programming language where there's simply nothing to read: http://en.wikipedia.org/wiki/Whitespace_(programming_language)

Being more human-readable than most was one of the early selling points of Ada. I find it a silly argument these days, as any sufficently complex task in any language is going to require a competent practicioner to understand. However, it does beat the bejeezus out of C-syntax languages. Its dominant coding styles can enhance this effect too. For example, comparing loops in an if statement:
Ada:
if Time_To_Loop then
   for i in Some_Array loop
      Some_Array(i) := i;
   end loop;
end if;

C:
if (timeToLoop != 0) {
   for (int i=0;i<SOME_ARRAY_LENGTH;i++) {
      someArray[i] = i;
   }
}

The C code would look even worse if I used Hungarian notation like Microsoft, but I'm trying to be nice. :-)


Projects promoting programming in
  "natural language" are intrinsically
  doomed to fail.

-- Edsger W.Dijkstra, How do we tell truths that might hurt?

Funny. Imagine an analphabet asking "Is there a human readable newspaper?".
Before you can read something you have to learn to read first.

SQL
SELECT name, address FROM customers WHERE region = 'Europe'


In the early days Microsoft actually translated WordBasic (since many years known as Visual Basic for Applications) to match the GUI language. Constructs like 
If <condition> Then
  <something>
End If

would, in the Dutch version of Word, be entered and displayed like
Als <condition> Dan
  <something>
Einde Als

Of course, in theory this made it easier for people to understand recorded macros. But I doubt those people would ever take a look at the code to start with...

There are lots of great DSLs (Domain Specific Languages) that read very much like human language.
A great example is Starbucks.  You could write a DSL like this.  This is using Ruby but could be done in many different languages. The advantages to Ruby or Python is that they are dynamic languages so you can use Duck Typing.



venti = Starbucks.new(:kind => :coffee, :size => :venti)
half_foam_venti = add_half_foam(venti)
serve(half_foam_venti)



But I have to agree that Ruby / Python might be the closest out of the box.
Kent

Haven't seen ABC mentioned yet. Worked with that during first year computer science at Utrecht University and always thought that quite "human readable" (whatever that means exactly).
Here is an example function words to collect the set of all words in a document:
   HOW TO RETURN words document:
      PUT {} IN collection
      FOR line IN document:
         FOR word IN split line:
            IF word not.in collection:
               INSERT word IN collection
      RETURN collection


I says LOLcode for readablity:
HAI
I HAS A VAR ITZ "Hai der Werld", I HAS END 
VISIBLE VAR
GIMMEH END
KTHXBYE
or
HAI
I HAS END
VISIBLE "Hai der Werld 2.0"
GIMMEH END
KTHXBYE
"w/o gimmeh the thing would only stay up for a split second"
go to lolcode.com for moar info

I used to be able to "read" OS/360 object code a talent born of many hours of 2 am dump analysis with the OPs manager pacing in the backgound. 
So I suppose OBJECT code counts as human readable.
The main problem with 'natural language' code is they can be so ambiguous. English especially depends on cultural, contextual and 'mood's to interpret a sentance correctly.
This is why legal documents are written in a such wierd stilted language, its the only way to acheive any sort of precision with English.
This was one of COBOLs big pitfalls.
The compilers interpretation of  'IF A NOT = B OR C ' was the exact opposite a a casual readers interprataion ie in C "!(A == B) || A == C" whereas you may think it should be !(A == B || A == C).
The other big problem was puncutuation. Your brain "preprocesses" punctuation so you dont really "see" it a concious level. The period '.' was vital in early COBOL as they delimited blocks of code, but missing or extra periods were maddeningly difficult to spot. Its a bit like spotting an '=' vs. '==' in C except much much worse.     

i think what you maybe referring to is Functional Programming? i think F# is 1. tho i seem to think its more complex to me as a developer

You should read Martin Fowler's essay on Business-Readable DSLs. 

PERL ;-)

Windev is very easy and human readable language.
http://www.pcsoft.fr/windev/presentation.htm

Rebol Comes Close 

While I know COBOL (and closer to us... SQL) can suck, these were designed decades ago. I also think they took advantage of the hype about "english" programming languages, and I dont think they went very far in proper linguistic analysis. I think it is possible to program in ENGLISH nowadays (natural english...the language) if good programmers got together and analyzed the language and put it to work. It is a big project, but with the computing power we have it is possible, I am pretty sure.
In other words, I don't like how people discard the idea of english-like programming because of COBOL. Cobol was an early programming language, and its designers back then decided to take spoken english as a reference, because they didn't know any better, they had no ideas of the complication laying ahead, and they thought english made it look familiar, and maybe it also looked good on marketing material. I don't think they tried really hard to make the COBOL compiler read natural english. If a serious effort was made nowadays to learn from the past and complete a proper system of natural language recognition, then I think it can work - after some time (most probably a matter of years).
And assuming that, wouldn't it be nice to be able to program in plain english? Of course, it would have to be self-learning (the computer has to learn stuff on the fly) and interactive (the computer must be able to ask the user to pick among choices when confused).

GradStudent
It only has one statement: "you - write me a program to do x"
It's valid for all values of X and has the advantage that x doesn't have to be defined and can be changed after the program is written.
A commercial dialect is available called intern: development cost is lower but it isn't guaranteed to work

Have you looked at Python?

Interesting question. Your question can be read as "Is there any programming language that is easily readable by humans?", OR ELSE as "Is there a human language that can be used for programming?". All the answers here have focused on the former, so let me try answering the latter.
Have you heard of Sanskrit? It is an ancient Indian language on which modern Indian languages like Hindi are based.
wiki/Sanskrit
I've been hearing for years that it is precise and complete enough to be used, as it is, as a high-level language on a computer. Ofcourse, you need a compiler to convert Sanskrit instructions to machine language.  I know the script & yes, it is precise (entirely phonetic so you never have to ask "how do you spell that"), but I don't know the grammer well enough.
This is completeley anecdotal, so I don't vouch for the accuracy of this. Just wanted to share what I know regarding this. :-)

Please check the web site from the Research and Incubation Center of Northwestern Polytechnic University,  http://www.jumpulse.com to see a human-language programming language New, which communicates exclusively in human language with the user.  New is based on a completely automated software.  It should be usable by people from 10-years old and up.
