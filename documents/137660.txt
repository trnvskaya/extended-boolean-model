Where does Console.WriteLine go in ASP.NET?
asp.net iis console.writeline
In a J2EE application (like one running in WebSphere), when I use System.out.println(), my text goes to standard out, which is mapped to a file by the WebSphere admin console.
In an ASP.NET application (like one running in IIS), where does the output of Console.WriteLine() go?  The IIS process must have a stdin, stdout and stderr; but is stdout mapped to the Windows version of /dev/null or am I missing a key concept here?
I'm not asking if I should log there (I use log4net), but where does the output go?  My best info came from this discussion where they say Console.SetOut() can change the TextWriter, but it still didn't answer the question on what the initial value of the Console is, or how to set it in config/outside of runtime code.


It would actually go to the STDOUT of the ASP.NET Worker process.
Where that is pointed to, I'm not sure.

In an ASP.NET application, I think it goes to the Output or Console window which is visible during debugging.

Unless you are in a strict console application, I wouldn't use it, because you can't really see it. I would use Trace.WriteLine() for debugging-type information that can be turned on and off in production.

There simply is no console listening by default. Running in debug mode there is a console attached, but in a production environment it is as you suspected, the message just doesn't go anywhere because nothing is listening.

If you use System.Diagnostics.Debug.WriteLine(...) instead of Console.WriteLine(), then you can see the results in the Output window of Visual Studio.

If you look at the Console class in .NET Reflector, you'll find that if a process doesn't have an associated console, Console.Out and Console.Error are backed by Stream.Null (wrapped inside a TextWriter), which is a dummy implementation of Stream that basically ignores all input, and gives no output.
So it is conceptually equivalent to /dev/null, but the implementation is more streamlined: there's no actual I/O taking place with the null device.
Also, apart from calling SetOut, there is no way to configure the default.

I've found this question by trying to change the Log output of the DataContext to the output window. So to anyone else trying to do the same,  what I've done was create this:
class DebugTextWriter : System.IO.TextWriter {
   public override void Write(char[] buffer, int index, int count) {
       System.Diagnostics.Debug.Write(new String(buffer, index, count));
   }

   public override void Write(string value) {
       System.Diagnostics.Debug.Write(value);
   }

   public override Encoding Encoding {
       get { return System.Text.Encoding.Default; }
   }
}

Annd after that: dc.Log = new DebugTextWriter() and I can see all the queries in the output window (dc is the DataContext).
Have a look at this for more info: http://damieng.com/blog/2008/07/30/linq-to-sql-log-to-debug-window-file-memory-or-multiple-writers

The TraceContext object in ASP.NET writes to the DefaultTraceListener which outputs to the host process' standard output. Rather than using Console.Write() if you use Trace.Write, output will go to the StdOut of the process.
You could use the System.Diagnostics.Process object to get the ASP.NET process for your site and monitor standard output using theOutputDataRecieved` event.

System.Diagnostics.Debug.WriteLine(...); gets it into the Immediate Window in Visual Studio 2008.
Go to menu Debug -> Windows -> Immediate:


If you are using IIS Express and launch it via a command prompt, it will leave the DOS window open, and you will see Console.Write statements there.
So for example get a command window open and type:
"C:\Program Files (x86)\IIS Express\iisexpress" /path:C:\Projects\Website1 /port:1655

This assumes you have a website directory at C:\Projects\Website1. It will start IIS Express and serve the pages in your website directory. It will leave the command windows open, and you will see output information there.  Let's say you had a file there, default.aspx, with this code in it:
<%@ Page Language="C#" %>
<html>
<body>
    <form id="form1" runat="server">
    Hello!

    <% for(int i = 0; i < 6; i++) %>
       <% { Console.WriteLine(i.ToString()); }%>

    </form>
</body>
</html>

Arrange your browser and command windows so you can see them both on the screen. Now type into your browser: http://localhost:1655/. You will see Hello! on the webpage, but in the command window you will see something like
Request started: "GET" http://localhost:1655/
0
1
2
3
4
5
Request ended: http://localhost:1655/default.aspx with HTTP status 200.0

I made it simple by having the code in a code block in the markup, but any console statements in your code-behind or anywhere else in your code will show here as well.

If you look in the debug window you will see console.writelines. 
