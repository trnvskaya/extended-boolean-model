In PHP, how do you change the key of an array element?
php arrays associative-array
I have an associative array in the form key => value where key is a numerical value, however it is not a sequential numerical value. The key is actually an ID number and the value is a count. This is fine for most instances, however I want a function that gets the human-readable name of the array and uses that for the key, without changing the value.
I didn't see a function that does this, but I'm assuming I need to provide the old key and new key (both of which I have) and transform the array. Is there an efficient way of doing this?


You could use a second associative array that maps human readable names to the id's.  That would also provide a Many to 1 relationship.  Then do something like this:

echo 'Widgets: ' . $data[$humanreadbleMapping['Widgets']];



$arr[$newkey] = $arr[$oldkey];
unset($arr[$oldkey]);


if your array is built from a database query, you can change the key directly from the mysql statement:
instead of
"select Â´idÂ´ from Â´tablenameÂ´..."

use something like:
"select Â´idÂ´ **as NEWNAME** from Â´tablenameÂ´..."


The answer from KernelM is nice, but in order to avoid the issue raised by Greg in the comment (conflicting keys), using a new array would be safer
$newarr[$newkey] = $oldarr[$oldkey];
$oldarr=$newarr;
unset($newarr);


I like KernelM's solution, but I needed something that would handle potential key conflicts (where a new key may match an existing key). Here is what I came up with:
    function swapKeys( &$arr, $origKey, $newKey, &$pendingKeys ) {
        if( !isset( $arr[$newKey] ) ) {
            $arr[$newKey] = $arr[$origKey];
            unset( $arr[$origKey] );
            if( isset( $pendingKeys[$origKey] ) ) {
                // recursion to handle conflicting keys with conflicting keys
                swapKeys( $arr, $pendingKeys[$origKey], $origKey, $pendingKeys );
                unset( $pendingKeys[$origKey] );
            }
        } elseif( $newKey != $origKey ) {
            $pendingKeys[$newKey] = $origKey;
        }
    }

You can then cycle through an array like this:
    $myArray = array( '1970-01-01 00:00:01', '1970-01-01 00:01:00' );
    $pendingKeys = array();
    foreach( $myArray as $key => $myArrayValue ) {
        // NOTE: strtotime( '1970-01-01 00:00:01' ) = 1 (a conflicting key)
        $timestamp = strtotime( $myArrayValue );
        swapKeys( $myArray, $key, $timestamp, $pendingKeys );
    }

    // RESULT: $myArray == array( 1=>'1970-01-01 00:00:01', 60=>'1970-01-01 00:01:00' )


If your array is recursive you can use this function:
test this data:
    $datos = array
    (
        '0' => array
            (
                'no' => 1,
                'id_maquina' => 1,
                'id_transaccion' => 1276316093,
                'ultimo_cambio' => 'asdfsaf',
                'fecha_ultimo_mantenimiento' => 1275804000,
                'mecanico_ultimo_mantenimiento' =>'asdfas',
                'fecha_ultima_reparacion' => 1275804000,
                'mecanico_ultima_reparacion' => 'sadfasf',
                'fecha_siguiente_mantenimiento' => 1275804000,
                'fecha_ultima_falla' => 0,
                'total_fallas' => 0,
            ),

        '1' => array
            (
                'no' => 2,
                'id_maquina' => 2,
                'id_transaccion' => 1276494575,
                'ultimo_cambio' => 'xx',
                'fecha_ultimo_mantenimiento' => 1275372000,
                'mecanico_ultimo_mantenimiento' => 'xx',
                'fecha_ultima_reparacion' => 1275458400,
                'mecanico_ultima_reparacion' => 'xx',
                'fecha_siguiente_mantenimiento' => 1275372000,
                'fecha_ultima_falla' => 0,
                'total_fallas' => 0,
            )
    );

here is the function:
function changekeyname($array, $newkey, $oldkey)
{
   foreach ($array as $key => $value) 
   {
      if (is_array($value))
         $array[$key] = changekeyname($value,$newkey,$oldkey);
      else
        {
             $array[$newkey] =  $array[$oldkey];    
        }

   }
   unset($array[$oldkey]);          
   return $array;   
}


The way you would do this and preserve the ordering of the array is by putting the array keys into a separate array, find and replace the key in that array and then combine it back with the values. 
Here is a function that does just that:
function change_key( $array, $old_key, $new_key) {

    if( ! array_key_exists( $old_key, $array ) )
        return $array;

    $keys = array_keys( $array );
    $keys[ array_search( $old_key, $keys ) ] = $new_key;

    return array_combine( $keys, $array );
}


If you want also the position of the new array key to be the same as the old one you can do this:
function change_array_key( $array, $old_key, $new_key) {
    if(!is_array($array)){ print 'You must enter a array as a haystack!'; exit; }
    if(!array_key_exists($old_key, $array)){
        return $array;
    }

    $key_pos = array_search($old_key, array_keys($array));
    $arr_before = array_slice($array, 0, $key_pos);
    $arr_after = array_slice($array, $key_pos + 1);
    $arr_renamed = array($new_key => $array[$old_key]);

    return $arr_before + $arr_renamed + $arr_after;
}


this code will help to change the oldkey to new one
 $i = 0;
$keys_array=array("0"=>"one","1"=>"two");

$keys = array_keys($keys_array);

 for($i=0;$i<count($keys);$i++)
{
$keys_array[$keys_array[$i]]=$keys_array[$i];
unset($keys_array[$i]);
}
 print_r($keys_array);

display like
    $keys_array=array("one"=>"one","two"=>"two");


Easy stuff:
this function will accept the target $hash and $replacements is also a hash containing newkey=>oldkey associations.
This function will preserve original order, but could be problematic for very large (like above 10k records) arrays regarding performance & memory.
function keyRename(array $hash, array $replacements) {
    $new=array();
    foreach($hash as $k=>$v)
    {
        if($ok=array_search($k,$replacements))
            $k=$ok;
        $new[$k]=$v;
    }
    return $new;    
}

this alternative function would do the same, with far better performance & memory usage, at the cost of loosing original order (which should not be a problem since it is hashtable!)
function keyRename(array $hash, array $replacements) {

    foreach($hash as $k=>$v)
        if($ok=array_search($k,$replacements))
        {
          $hash[$ok]=$v;
          unset($hash[$k]);
        }

    return $hash;       
}


Here is a helper function to achieve that:
/**
 * Helper function to rename array keys.
 */
function _rename_arr_key($oldkey, $newkey, array &$arr) {
  if (array_key_exists($oldkey, $arr)) {
    $arr[$newkey] = $arr[$oldkey];
    unset($arr[$oldkey]);
    return TRUE;
  } else {
    return FALSE;
  }
}

pretty based on @KernelM answer.
Usage:
_rename_arr_key('oldkey', 'newkey', $my_array);

It will return true on successful rename, otherwise false.

$array = [
    'old1' => 1
    'old2' => 2
];

$renameMap = [
    'old1' => 'new1',   
    'old2' => 'new2'
];

$array = array_combine(array_map(function($el) use ($renameMap) {
    return $renameMap[$el];
}, array_keys($array)), array_values($array));

/*
$array = [
    'new1' => 1
    'new2' => 2
];
*/


this works for renaming the first key:
$a = ['catine' => 'cat', 'canine'  => 'dog'];
$tmpa['feline'] = $a['catine'];
unset($a['catine']);
$a = $tmpa + $a;

then, print_r($a) renders a repaired in-order array:
Array
(
    [feline] => cat
    [canine] => dog
)

this works for renaming an arbitrary key:
$a = ['canine'  => 'dog', 'catine' => 'cat', 'porcine' => 'pig']
$af = array_flip($a)
$af['cat'] = 'feline';
$a = array_flip($af)

print_r($a)
Array
(
    [canine] => dog
    [feline] => cat
    [porcine] => pig
)

a generalized function:
function renameKey($oldkey, $newkey, $array) {
    $val = $array[$oldkey];
    $tmp_A = array_flip($array);
    $tmp_A[$val] = $newkey;

    return array_flip($tmp_A);
}


If you want to replace several keys at once (preserving order):
/**
 * Rename keys of an array
 * @param array $array (asoc)
 * @param array $replacement_keys (indexed)
 * @return array
 */
function rename_keys($array, $replacement_keys)  {
      return array_combine($replacement_keys, array_values($array));
}

Usage:
$myarr = array("a" => 22, "b" => 144, "c" => 43);
$newkeys = array("x","y","z");
print_r(rename_keys($myarr, $newkeys));
//must return: array("x" => 22, "y" => 144, "z" => 43);

