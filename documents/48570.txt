Something like a callback delegate function in php
php oop
I would like to implement something similar to a c# delegate method in PHP.  A quick word to explain what I'm trying to do overall:  I am trying to implement some asynchronous functionality.  Basically some resource-intensive calls that get queued, cached, and dispatched when the underlying system gets around to it.  When the asynchronous call finally receives a response I would like a callback event to be raised.
I am having some problems coming up with a mechanism to do callbacks in PHP.  I have come up with a method that works for now but I am unhappy with it.  Basically it involves passing a reference to the object and the name of the method on it that will serve as the callback (taking the response as an argument) and then use eval to call the method when need be.  This is sub-optimal for a variety of reasons, is there a better way of doing this that anyone knows of? 


How do you feel about using the Observer pattern? If not, you can implement a true callback this way:
// This function uses a callback function. 
function doIt($callback) 
{ 
    $data = "this is my data";
    $callback($data); 
} 


// This is a sample callback function for doIt(). 
function myCallback($data) 
{ 
    print 'Data is: ' .  $data .  "\n"; 
} 


// Call doIt() and pass our sample callback function's name. 
doIt('myCallback');

Displays: Data is: this is my data

(Apart from the observer pattern) you can also use call_user_func() or call_user_func_array().
If you pass an array(obj, methodname) as first parameter it will invoked as $obj->methodname().

<?php
class Foo {
    public function bar($x) {
        echo $x;
    }
}

function xyz($cb) {
    $value = rand(1,100);
    call_user_func($cb, $value);
}

$foo = new Foo;
xyz( array($foo, 'bar') );


I was wondering if we could use __invoke magic method to create "kind of" first class function and thus implement a callback
Sound something like that, for PHP 5.3
interface Callback 
{
    public function __invoke(); 
}

class MyCallback implements Callback
{
    private function sayHello () { echo "Hello"; }
    public function __invoke ()  { $this->sayHello(); } 
}

class MySecondCallback implements Callback
{
    private function sayThere () { echo "World"; }
    public function __invoke ()  { $this->sayThere(); }
}

class WhatToPrint
{
    protected $callbacks = array();
    public function register (Callback $callback) 
    {
        $this->callbacks[] = $callback;
        return $this;
    }
    public function saySomething ()
    {
        foreach ($this->callbacks as $callback) $callback(); 
    }
}

$first_callback = new MyCallback;
$second_callback = new MySecondCallback;
$wrapper = new WhatToPrint;
$wrapper->register($first_callback)->register($second_callback)->saySomething();


Will print HelloWorld
Hope it'll help ;)
But I'd prefer the Controller pattern with SPL for such a feature.
