What does the comma operator do?
c++ c operators comma-operator
What does the following code do in C/C++?
if (blah(), 5) {
    //do something
}



Comma operator is applied and the value 5 is used to determine the conditional's true/false.
It will execute blah() and get something back (presumably), then the comma operator is employed and 5 will be the only thing that is used to determine the true/false value for the expression.

Note that the , operator could be overloaded for the return type of the blah() function (which wasn't specified), making the result non-obvious.

I would say that depends on blah().

If the comma operator is not overloaded, the code is similar to this:
blah();
if (5) {
  // do something
}

If the comma operator is overloaded, the result will be based on that function.
#include <iostream>
#include <string>

using namespace std;

string blah()
{
    return "blah";
}

bool operator,(const string& key, const int& val) {
    return false;
}

int main (int argc, char * const argv[]) {

    if (blah(), 5) {
        cout << "if block";
    } else {
        cout << "else block";
    }

    return 0;
}

(edited to show comma operator overloading scenario. thanks to David Pierre for commenting on this)

The following was written assuming it is C code, either in a C file or within a C block of a C++ file:
It is a pointless if. It will call blah(), however the result of blah() is not considered by if at all. The only thing being considered is 5, thus the if will always evaluate to true. IOW you could write this code as
blah();
// do something

without any if at all.

In the pathological case, it depends on what the comma operator does...
class PlaceHolder
{
};

PlaceHolder Blah() { return PlaceHolder(); }

bool operator,(PlaceHolder, int) { return false; }

if (Blah(), 5)
{
    cout << "This will never run.";
}


I know one thing that this kind of code should do: it should get the coder fired. I would be quite a bit afraid to work next to someone who writes like this.

On a more broad answer. The comma operator (non overloaded)  resolves as in, execute the first part and return the second part.
So if you have (foo(),bar()) Both functions will be executed, but the value of the expression evaluates to bar() (and the type of the expression as well).
While I won't say there are fair usages for that, is  usually considered a bit hard to read code. Mainly because not many languages shares such constructs. So As a personal rule of thumb I avoid it unless I am adding code to a preexistent expression and don't want to change completely its format.
Example: I have a Macro (not discussing if you should use macros or not, sometimes its not even you that wrote it)  
FIND_SOMETHING(X) (x>2) ? find_fruits(x) : find_houses(x)
And I usually use it in assignments like my_possession = FIND_SOMETHING(34);
Now I want to add log to it for debuggin purposes but I cannot change the find functions,. I could do :
FIND_SOMETHING(X) (x>2)? (LOG("looking for fruits"),find_fruits(x)):(LOG("looking for houses"),find_houses(x))

I use sometimes constructs like this for debugging purposes. When I force the if close to be true regardless of the return value of blah. 
It's obvious that it should never appear in production code.
