Why does GCC-Windows depend on cygwin?
windows gcc cygwin posix compiler-construction
I'm not a C++ developer, but I've always been interested in compilers, and I'm interested in tinkering with some of the GCC stuff (particularly LLVM).
On Windows, GCC requires a POSIX-emulation layer (cygwin or MinGW) to run correctly.
Why is that?
I use lots of other software, written in C++ and cross-compiled for different platforms (Subversion, Firefox, Apache, MySQL), and none of them require cygwin or MinGW.
My understanding about C++ best-practice programming is that you can write reasonably platform-neutral code and deal with all the differences during the compilation process.
So what's the deal with GCC? Why can't it run natively on Windows?

EDIT:
Okay, the two replies so far say, basically, "GCC uses the posix layer because it uses the posix headers".
But that doesn't really answer the question.
Let's say I already have a set of headers for my favorite standard library. Why would I still need the posix headers?
Does GCC require cygwin/mingw to actually RUN?
Or does it only need the emulation layer for headers and libraries? If so, why can't I just give it a "lib" directory with the required resources?

EDIT AGAIN:
Okay, I'll try again to clarify the question...
I also write code in the D Programming Language. The official compiler is named "dmd" and there are official compiler binaries for both Windows and linux.
The Windows version doesn't require any kind of POSIX emulation. And the Linux version doesn't require any kind of Win32 emulation. If the compiler has assumptions about its environment, it hides those assumptions pretty well.
Of course, I have to tell the compiler where to find the standard library and where to find libraries to statically or dynamically link against.
GCC, by contrast, insists on pretending it's operating within a posix environment, and it asks ME to humor those assumptions by setting up an emulation layer.
But what, exactly, within GCC relies on that layer? Is it just looking for stdlib headers, and it assumes it'll find those headers within "/usr/lib"?
If that's the case, shouldn't I just be able to tell it to look in "C:/gcc/lib" to find those header files?
Or does GCC itself rely on the POSIX libraries to access the file system (and to do other low-level stuff)? If that's the case, then I wonder why they don't just statically link with their favorite windows POSIX libraries. Why require the user to set up the dependencies, when they could build those dependencies right into the application?


Much of that software that is compiled for different platforms is compiled... in MinGW.  The only difference with gcc is that it is a compiler itself, which means it needs all the headers that normally get compiled in with the program, and normally which one does not need to run the resulting program.

Windows does not offer a standard POSIX library so cygwin provides one (cygwin1.dll). The gcc packages that comes with cygwin uses it.
mingw, on the other hand, does not necessarely provide a POSIX layer. The mingw installation that I use, for example, does not even have a pthread library.
Should I need it I would have to install it. Mingw-gcc produces Win32 native code (and in fact relies on MSVCRT.DLL).
EDIT: reading your edit I'm no longer sure if you're asking why gcc itself needs mingw/cygwin libraries or if the programs compiled with gcc on Win require those libraries

Actually, the question premise is wrong: MinGW GCC does NOT require Cygwin.
You will see you don't need Cygwin at all. It runs natively on Windows (32-bit, at least). Both the toolchain and the produced binaries are independent of Cygwin.
The MinGW compilers available in Cygwin are different: they are built on the Cygwin platform, to generate code which does not depend on the Cygwin runtime. The compilers themselves do depend on Cygwin in that case. But that's because you installed them from Cygwin.

I try to make my programs under Windows behave like a good Windows citizen, and under Linux like a good Linux citizen.

The Cygwin version of GCC requires Cygwin to be installed, for programs it compiles.
The MinGW version does not require anything after compiling, other than a working copy of Windows.
You can't really mix the Cygwin environment, and the MinGW compilers together, because Cygwin changes the paths of the precompiled libraries.
If you need a bash style shell, but don't want to use Cygwin, I would recommend MSYS.
Cygwin in contrast to MinGW
copied from MinGW Wiki

Cygwin applications by principle are not considered a "Native Win32 application" because it relies on the CygwinÂ® POSIX Emulation DLL or cygwin1.dll for Posix functions and does not use win32 functions directly. MinGW on the other hand, provides functions supplied by the Win32 API. While porting applications under MinGW, functions not native to Win32 such as fork(), mmap() or ioctl() will need to be reimplemented into Win32 equivalents for the application to function properly.


POSIX (Portable Operating System Interface) "is an evolving, growing document that is being produced by IEEE and standardized by ANSI and ISO.  The goal of POSIX is the source-code portability of application" [1].
In practical terms, the goal is defined as the ability to write one source implementation and have it run on different (POSIX-compliant) systems with only recompilation.
GCC is a compiler capable of delivering that promise and as such, it needs a layer of code that brings a machine "up to" POSIX standards.
That is the core of the answer to your question.
To help see what I mean, I'll offer you this exercise:

Write a program with no OS-specific #ifdefs that takes as input from the user some directory path and writes to stdout a listing of its contents (one level).

I think you will find that it is very difficult to write code that uses only the native WIN32 API that compiles on any UNIX or LINUX system 
It will be only slightly less difficult to write code that uses POSIX API - as you can on any LINUX box - and have it compile under Windows (DevStudio2005 has a surprising number of POSIX-compliant headers now...you might be able to get close).
Take you LINUX program from above and now compile it under GCC running under Cygwin or MinGW.  I'll bet it compiles and runs.
How did GCC perform that bit of magic?  The POSIX headers and implementations underlying them provided by Cygwin or MinGW.
Does GCC's reliance on Cygwin/MinGW under Windows make more sense now?

POSIX.4: Programming for the Real World, Bill O. Gallmeister, O'Reilly & Associates, Inc., pg 2


Why? Because when GCC was created, Windows 32 bit even hadn't exits...
To be more correct --- it was developed for UNIX/Posix OS. Later it was ported to windows.
Windows is not POSIX compient system. It even does not provide very basic functionality. Try to find readdir or stat under Windows compiler? And this is so extreamly basic functionality that you need to write compiler!
Just to be clear, GCC compiled programs usually required only one mingw32.dll to add missing functionality to be able to run.
So... You ask why GCC requires some POSIX layer? Because Windows OS is not POSIX operating system.


I'm not a C++ developer, but I've
  always been interested in compilers,
  and I'm interested in tinkering with
  some of the GCC stuff (particularly
  LLVM)

Note that LLVM and GCC are not related. LLVM is largely the result of the research done by Chris Lattner (http://llvm.org/developers.cgi) about modern optimization. His papers are available on http://llvm.org. Nowadays, it is heavily sponsored by Apple. GCC's C/C++/Obj-C frontend is used for llvm-gcc, which emits LLVM machine code (and after a ton of optimizations in llvm, a final executable comes out); llvm-gcc is a kind of hack to couple some ready C/C++/Obj-C-frontend to LLVM. 
Note anyways that the LLVM crew also builds an own, complete C/C++/Obj-C compiler, called clang. It's C implementation is near complete, C++ support is getting better and better, dunno about Obj-C though.
So, if someone says "compiler llvm", he really either means llvm-gcc, or clang. LLVM itself is just the Low Level Virtual Machine, with only a handful of instructions in Static Single Assignment form (approx. 32 instructions, afair), but a megaton of optimization passes upon thy syntax tree.

Because the people behing GCC hate Windows with a passion (read Stallman some day). So when porting GCC to Windows, they do their best to pretend it's just another Unix.
That, and they probably don't want to spend time on removing POSIX dependencies from the code.

The MinGW-w64 port of gcc creates native code for 32- and 64-bit Windows without any additional dependencies.
See for example http://mstenberg.com/blog/2010/06/13/gcc-for-windows/ for a quick getting-started guide.

You have an option when building gcc to specify enable-threads options other than posix, if you don't want to support pthreads or OpenMP.  Needless to say, those aren't as well tested.  There is some 3rd party closed source support for OpenMP with Windows threads, but its use with gcc appears to violate the license.
As the Windows pthreads library is a higher level interface to Windows threads functionality, it's perhaps not surprising when it doesn't perform as well or encounters Microsoft's rejection of affinity support.
Only recently has Microsoft begun to tolerate gcc on Windows.  There was a time when they actually said they would not work on bugs reported by gcc users, even if they could be reproduced with exclusively Microsoft tools.
