Aren't Information Expert / Tell Don't Ask at odds with Single Responsibility Principle?
oop srp tell-dont-ask
It is probably just me, which is why I'm asking the question. Information Expert, Tell Don't Ask, and SRP are often mentioned together as best practices. But I think they are at odds. Here is what I'm talking about:
Code that favors SRP but violates Tell Don't Ask, Info Expert:
Customer bob = ...;
// TransferObjectFactory has to use Customer's accessors to do its work, 
// violates Tell Don't Ask
CustomerDTO dto = TransferObjectFactory.createFrom(bob);

Code that favors Tell Don't Ask / Info Expert but violates SRP:
Customer bob = ...;
// Now Customer is doing more than just representing the domain concept of Customer,
// violates SRP
CustomerDTO dto = bob.toDTO();

If they are indeed at odds, that's a vindication of my OCD. Otherwise, please fill me in on how these practices can co-exist peacefully. Thank you.
Edit: someone wants a definition of the terms - 
Information Expert: objects that have the data needed for the operation should host the operation
Tell Don't Ask: don't ask objects for data in order to do work; tell the objects to do the work
Single Responsibility Principle: each object should have a narrowly defined responsibility


I don't think that they are so much at odds as they are emphasizing different things that will cause you pain. One is about structuring code to make it clear where particular responsibilities are and reducing coupling, the other is about reducing the reasons to modify a class.
We all have to make decisions each and every day about how to structure code and what dependencies we are willing to introduce into designs.  
We have built up a lot of useful guidelines, maxims and patterns that can help us to make the decisions.  
Each of these is useful to detect different kinds of problems that could be present in our designs. For any specific problem that you may be looking at there will be a sweet spot somewhere.  
The different guidelines do contradict each other. Just applying every piece of guidance you have heard or read will not make your design better.  
For the specific problem you are looking at today you need to decide what the most important factors that are likely to cause you pain are.  

Those classes are not at odds.  The DTO is simply serving as a conduit of data from storage that is intended to be used as a dumb container.  It certainly doesn't violate the SRP.  
On the other hand the .toDTO method is questionable -- why should Customer have this responsibility?  For "purity's" sake I would have another class who's job it was to create DTOs from business objects like Customer.  
Don't forget these principles are principles, and when you can et away with simpler solutions until changing requirements force the issue, then do so.  Needless complexity is definitely something to avoid.
I highly recommend, BTW, Robert C. Martin's Agile Patterns, Practices and principles for much more in depth treatments of this subject.

You can talk about "Tell Don't Ask" when you ask for object's state in order to tell object to do something.
In your first example TransferObjectFactory.createFrom just a converter. It doesn't tell Customer object to do something after inspecting it's state.
I think first example is correct.

I don't 100% agree w/ your two examples as being representative, but from a general perspective you seem to be reasoning from the assumption of two objects and only two objects.
If you separate the problem out further and create one (or more) specialized objects to take on the individual responsibilities you have, and then have the controlling object pass instances of the other objects it is using to the specialized objects you have carved off, you should be able to observe a happy compromise between SRP (each responsibility has handled by a specialized object), and Tell Don't Ask (the controlling object is telling the specialized objects it is composing together to do whatever it is that they do, to each other). 
It's a composition solution that relies on a controller of some sort to coordinate and delegate between other objects without getting mired in their internal details.

DTOs with a sister class (like you have) violate all three principles you stated, and encapsulation, which is why you're having problems here. 
What are you using this CustomerDTO for, and why can't you simply use Customer, and have the DTOs data inside the customer? If you're not careful, the CustomerDTO will need a Customer, and a Customer will need a CustomerDTO.
TellDontAsk says that if you are basing a decision on the state of one object (e.g. a customer), then that decision should be performed inside the customer class itself. 
An example is if you want to remind the Customer to pay any outstanding bills, so you call
  List<Bill> bills = Customer.GetOutstandingBills();
  PaymentReminder.RemindCustomer(customer, bills);

this is a violation. Instead you want to do 
Customer.RemindAboutOutstandingBills() 

(and of course you will need to pass in the PaymentReminder as a dependency upon construction of the customer).
Information Expert says the same thing pretty much.
Single Responsibility Principle can be easily misunderstood - it says that the customer class should have one responsibility, but also that the responsibility of grouping data, methods, and other classes aligned with the 'Customer' concept should be encapsulated by only one class. What constitutes a single responsibility is extremely hard to define exactly and I would recommend more reading on the matter.
