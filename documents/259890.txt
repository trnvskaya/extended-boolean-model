OpenGL glDrawPixels on dynamic 3D arrays
c++ arrays opengl graphics
How do you draw the following dynamic 3D array with OpenGL glDrawPixels()?
You can find the documentation here: http://opengl.org/documentation/specs/man_pages/hardcopy/GL/html/gl/drawpixels.html
float ***array3d;

void InitScreenArray()
{
    int i, j;

    int screenX = scene.camera.vres;
    int screenY = scene.camera.hres;

    array3d = (float ***)malloc(sizeof(float **) * screenX);

    for (i = 0 ;  i < screenX; i++) {
    	array3d[i] = (float **)malloc(sizeof(float *) * screenY);

    	for (j = 0; j < screenY; j++)
    	  array3d[i][j] = (float *)malloc(sizeof(float) * /*Z_SIZE*/ 3);
    }
}

I can use only the following header files:
#include <math.h>
#include <stdlib.h>
#include <windows.h>     

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>



Uh ... Since you're allocating each single pixel with a separate malloc(), you will have to draw each pixel with a separate call to glDrawPixels(), too. This is (obviously) insane; the idea of bitmapped graphics is that the pixels are stored in an adjacent, compact, format, so that it is quick and fast (O(1)) to move from one pixel to another. This looks very confused to me.
A more sensible approach would be to allocate the "3D array" (which is often referred to as a 2D array of pixels, where each pixel happens to consist of a red, green and blue component) with a single call to malloc(), like so (in C):
float *array3d;
array3d = malloc(scene.camera.hres * scene.camera.vres * 3 * sizeof *array3d);


Thanks unwind. I got the same advice on gamedev.net so I have implemented the following algorithm:
typedef struct
{
    GLfloat R, G, B;
} color_t;

color_t *array1d;

void InitScreenArray()
{   
        long screenX = scene.camera.vres;
    long screenY = scene.camera.hres;
        array1d = (color_t *)malloc(screenX * screenY * sizeof(color_t));
}

void SetScreenColor(int x, int y, float red, float green, float blue)
{
    int screenX = scene.camera.vres;
    int screenY = scene.camera.hres;

    array1d[x + y*screenY].R = red;
    array1d[x + y*screenY].G = green;
    array1d[x + y*screenY].B = blue;
}

void onDisplay( ) 
{
    glClearColor(0.1f, 0.2f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glRasterPos2i(0,0);	
    glDrawPixels(scene.camera.hres, scene.camera.vres, GL_RGB, GL_FLOAT, array1d);

    glFinish();
    glutSwapBuffers();
}

My application doesn't work yet (nothing appears on screen), but I think it's my fault and this code will work.

wouldn't you want to use glTexImage2D() instead: see here
