What's the difference between Polymorphism and Multiple Dispatch?
oop polymorphism multiple-dispatch double-dispatch
...or are they the same thing? I notice that each has its own Wikipedia entry: [1] [2], but I'm having trouble seeing how the concepts differ.
Edit: And how does Overloading fit into all this?


Multiple Dispatch is a kind of Polymorphism.  In Java/C#/C++, there is polymorphism through inheritance and overriding, but that is not Multiple Dispatch, which is based on 2 or more arguments (not just this, like in Java/C#/C++)

Multiple Dispatch is more akin to function overloading (as seen in Java/C++), except the function invoked depends on the run-time type of the arguments, not their static type.

Multiple Dispatch relies on polymorphism based.  Typical polymorphism encountered in C++, C#, VB.NET, etc... uses single dispatch -- i.e. the function that gets called only depends on a single class instance.  Multiple dispatch relies on multiple class instances.

I've never heard of Multiple Dispatch before, but after glancing at the Wikipedia page it looks a lot like MD is a type of polymorphism, when used with the arguments to a method.  
Polymorphism is essentially the concept that an object can be seen as any type that is it's base.  So if you have a Car and a Truck, they can both be seen as a Vehicle.  This means you can call any Vehicle method for either one.
Multiple dispatch looks similar, in that it lets you call methods with arguments of multiple types, however I don't see certain requirements in the description.  First, it doesn't appear to require a common base type (not that I could imagine implementing THAT without void*) and you can have multiple objects involved.
So instead of calling the Start() method on every object in a list, which is a classic polymorphism example) you can call a StartObject(Object C) method defined elsewhere and code it to check the argument type at run time and handle it appropriately.  The difference here is that the Start() method must be built into the class, while the StartObject() method can be defined outside of the class so the various objects don't need to conform to an interface.
Which could be nice if the Start() method needed to be called with different arguments.  Maybe Car.Start(Key carKey) vs. Missile.Start(int launchCode)
But both could be called as StartObject(theCar) or StartObject(theMissile)
Interesting concept...

if you want the conceptual equivalent of a method invocation
(obj_1, obj_2, ..., obj_n)->method

to depend on each specific type in the tuple, then you want multiple dispatch.  Polymorphism corresponds to the case n=1 and is a necessary feature of OOP.

With multiple dispatch, a method can have multiple arguments passed to it and which implementation is used depends on each argument's type. The order that the types are evaluated depends on the language. In LISP, it checks each type from first to last.
Languages with multiple dispatch make use of generic functions, which are just function delcarations and aren't like generic methods, which use type parameters.
Multiple dispatch allows for subtyping polymorphism of arguments for method calls. 
Single-dispatch also allows for a more limited kind of polymorphism (same method name for objects that implement the same interface or inherit the same base class). It's the classic example of polymorphism, where you have methods that are overriden in subclasses.
Beyond that, generics provide parametric type polymorphism (e.g., same generic interface to use with different types, even if they're not related, like List< T> -- it can be a list of any type and is used the same way regardless).

Polymorphism is the facility that allows a language/program to make decisions during runtime on which method to invoke based on the types of the parameters sent to that method. 
The number of parameters used by the language/runtime determines the 'type' of polymorphism supported by a language. 
Single dispatch is a type of polymorphism where only one parameter is used (the receiver of the message - this, or self) to determine the call.
Multiple dispatch is a type of polymorphism where in multiple parameters are used in determining which method to call. In this case, the reciever as well as the types of the method parameters are used to tell which method to invoke.
So you can say that polymorphism is the general term and multiple and single dispatch are specific types of polymorphism.
Addendum: Overloading happens during compile time. It uses the type information available during compilation to determine which type of method to call. Single/multiple dispatch happens during runtime.
Sample code:
using NUnit.Framework;

namespace SanityCheck.UnitTests.StackOverflow
{
    [TestFixture]
    public class DispatchTypes
    {
        [Test]
        public void Polymorphism()
        {
            Baz baz = new Baz();
            Foo foo = new Foo();

            // overloading - parameter type is known during compile time
            Assert.AreEqual("zap object", baz.Zap("hello"));
            Assert.AreEqual("zap foo", baz.Zap(foo));


            // virtual call - single dispatch. Baz is used.
            Zapper zapper = baz;
            Assert.AreEqual("zap object", zapper.Zap("hello"));
            Assert.AreEqual("zap foo", zapper.Zap(foo));


            // C# has doesn't support multiple dispatch so it doesn't
            // know that oFoo is actually of type Foo.
            //
            // In languages with multiple dispatch, the type of oFoo will 
            // also be used in runtime so Baz.Zap(Foo) will be called
            // instead of Baz.Zap(object)
            object oFoo = foo;
            Assert.AreEqual("zap object", zapper.Zap(oFoo));
        }

        public class Zapper
        {
            public virtual string Zap(object o) { return "generic zapper" ; }
            public virtual string Zap(Foo f) { return "generic zapper"; }
        }

        public class Baz : Zapper
        {
            public override string Zap(object o) { return "zap object"; }
            public override string Zap(Foo f) { return "zap foo"; }
        }

        public class Foo { }
    }
}

