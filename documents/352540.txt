How to create an XPS document?
c# .net xps xpsdocument
I'd like to create an XPS document for storing and printing.
What is the easiest way to create an XPS document (for example with a simple grid with some data inside) in my program, and to pass it around?


All it is, is really XML. If you're comfortable working with XML files, you should have no problem working with XPS documents. Here's a simple tutorial I've used in the past to get me started:
http://blogs.ocrasoft.nl/jeroenveurink/?p=21

Nothing easy about it.  But it can be done.  I've got some (sadly, still buggy) sample code and information on my blog for creating the document in memory.
Here's some code I whipped up for testing that encapsulates everything (it writes a collection of FixedPages to an XPS document in memory).  It includes code for serializing the document to a byte array, but you can skip that part and just return the document:
public static byte[] ToXpsDocument(IEnumerable<FixedPage> pages)
{
    // XPS DOCUMENTS MUST BE CREATED ON STA THREADS!!!
    // Note, this is test code, so I don't care about disposing my memory streams
    // You'll have to pay more attention to their lifespan.  You might have to 
    // serialize the xps document and remove the package from the package store 
    // before disposing the stream in order to prevent throwing exceptions
    byte[] retval = null;
    Thread t = new Thread(new ThreadStart(() =>
    {
        // A memory stream backs our document
        MemoryStream ms = new MemoryStream(2048);
        // a package contains all parts of the document
        Package p = Package.Open(ms, FileMode.Create, FileAccess.ReadWrite);
        // the package store manages packages
        Uri u = new Uri("pack://TemporaryPackageUri.xps");
        PackageStore.AddPackage(u, p);
        // the document uses our package for storage
        XpsDocument doc = new XpsDocument(p, CompressionOption.NotCompressed, u.AbsoluteUri);
        // An xps document is one or more FixedDocuments containing FixedPages
        FixedDocument fDoc = new FixedDocument();
        PageContent pc;
        foreach (var fp in pages)
        {
            // this part of the framework is weak and hopefully will be fixed in 4.0
            pc = new PageContent();
            ((IAddChild)pc).AddChild(fp);
            fDoc.Pages.Add(pc);
        }
        // we use the writer to write the fixed document to the xps document
        XpsDocumentWriter writer;
        writer = XpsDocument.CreateXpsDocumentWriter(doc);
        // The paginator controls page breaks during the writing process
        // its important since xps document content does not flow 
        writer.Write(fDoc.DocumentPaginator);
        // 
        p.Flush();

        // this part serializes the doc to a stream so we can get the bytes
        ms = new MemoryStream();
        var writer = new XpsSerializerFactory().CreateSerializerWriter(ms);
        writer.Write(doc.GetFixedDocumentSequence());

        retval = ms.ToArray();
    }));
    // Instantiating WPF controls on a MTA thread throws exceptions
    t.SetApartmentState(ApartmentState.STA);
    // adjust as needed
    t.Priority = ThreadPriority.AboveNormal;
    t.IsBackground = false;
    t.Start();
    //~five seconds to finish or we bail
    int milli = 0;
    while (buffer == null && milli++ < 5000)
        Thread.Sleep(1);
    //Ditch the thread
    if(t.IsAlive)
        t.Abort();
    // If we time out, we return null.
    return retval;
}

Note the crappy threading code.  You can't do this on MTA threads; if you are on an STA thread you can get rid of that as well.

If you are working in .NET (v2 or later), you can very easily generate a valid XPS document from a WPF visual.
For an example, take a look at this blog post of mine:
http://nixps.blogspot.com/2008/12/wpf-to-pdf.html
In the example I create a WPF visual and convert it as an XPS file, before doing further processing.
If you are not working in .NET, or want more control on the XPS output, then I would advise you to use a library (like the NiXPS SDK) for this. It is a lot easier to code for, and a lot less error prone than writing out the XML constructs yourself (and doing proper resource management, etc...).
