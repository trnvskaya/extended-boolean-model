unions declaration C code
c unions
I have seen some declaration of a union inside a struct as follows. Example code given below.
My questions is does it help in any memory savings(typical use for which a union is used for)? I do not see the benefit. 
typedef struct
{
    int x1;
    unsigned int x2;
    ourstruct1 ov1;
    ourstruct1 ov2;
    union
    {
            struct
            {
                mystruct1 v1;
                mystruct2 v2;
                mystruct3 v3;
                int* ctxSC;
                mystruct4 v4;
                Bool v5;
                Long v6;
                Long v7;
                Long v8;
                Long v9;
            }mystr;
    };
}structvar1;

-AD


Hmm.  Well, the example above seems a little strange to me--the usual reason for a union is to have two different symbolic paths into the same storage (by bytes, by words, etc).  However, the example you've given has only one member of the union.
The only thing I can think is that the code is written with an eye towards future expansion--I.E. that the union will, in subsequent versions, have additional members.

This is not a typical use for a union at all. Unions are variant types - you can put many different kind of types into them and retrieve them. Putting only one type into a union gives you nothing, except weird looking code.

It would seem to me that the union isn't actually used here.  I've never seen a lone struct inside a union like that either.  Strange.

It's hard to say with the obfuscated names of variables and types meant to make the code anonymous, but is it possible the person that wrote it was erroneously expecting the fields inside of the mystr struct to be union'ed?

Is this code valid ? Not because the union has only one field (albeit this seems weird), but because the union is anonymous ; how do you tell the compiler you want to address in the inner struct mystr ? 
 structvar1 var1;
 var1.mystr.ctxSC = NULL;  // compile error : structvar1 has no mystr member

And GCC 3.4.4 reports this as invalid ISO C. 
EDIT: Steve Fallows gave me the answer in a comment: this is a proprietary Microsoft extension that allow seamless structure aggregation: all the fields of the "included"  structure are considered as being part of the containing structure.

To add to what Philippe wrote: Microsoft uses this in DirectX to define its D3DMATRIX (and the derived structure `D3DXMATRIX) as follows:
typedef struct _D3DMATRIX {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
} D3DMATRIX;
This allows you to address the matrix elements either by name or by index: both myMat._12 and myMat.m[0][1] refer to the second element in the first row of the matrix myMat.  It's really just syntactic sugar, since even the most braindead compiler will optimize accesses such as myMat.m[0][1] into a constant offset calculation.

no you can not acheive benifit unoin should contain someother members but not only structure in.there is nothing wrong in it,but you can't get memory optimisation. 
