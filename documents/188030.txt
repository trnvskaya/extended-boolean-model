Mathematics and Game Programming
math 2d
I want to program graphical 2D games more complex than the basic 2D stuff I already know. I don't want to do 3D programming. Just more complex 2D stuff. I dropped high school before I could learn a lot of stuff so I walked away with enough algebra knowledge to balance my checkbook and do some light 2D Cartesian programming.
Are there any good resources out there for a guy with a limited attention span (say 20 minutes apiece for a subject I'm keenly interested in) to learn, gradually, how to do something more useful with math in programming?


I'm currently going through "Physics for Game Developers" by David M. Bourg. So far, I'd recommend it. 
It provides the math-y concepts behind physics that can easily be applied to the 2D realm to spice up your games a bit.

Strangely I've found a lot of useful stuff on linear algebra in Wikipedia: http://en.wikipedia.org/wiki/Portal:Mathematics 
Generally it's not the best source of knowledge, but math there is ok.

You need to be competent in Trigonometry: Wikipedia and Mathworld
Even though you don't wish to do 3D programming, 2D games also use vectors and matrices. (from Linear Algebra)
Linear Algebra resources: Wikepedia and   Mathworld
One point that will save you a lot of effort in Trig programming is realizing the need for the atan2() function, rather than the atan() function. This is important when determining the direction between two points.
Being able to move between various coordinate systems is a big plus. This will come with experience. Two common things that trip people up are:
a) Most screen systems place the origin (0,0) in the upper left corner, with the positive x axis extending to the right and the positive y axis extending down. Standard Cartesian coordinates suppose the origin of Quadrant 1 (where x and y are always positive or zero) in the lower left. This requires a programmer to 'flip' the y orientation at some stage.
b) Typical geography places 0 degrees as North and positive degrees sweep clockwise. All the Trig functions place 0 degrees as East with positive degrees sweeping counter-clockwise. 
Finally, even though we tend to think in degrees, real libraries will use radians.
A best practice is to store angles as radians (in 'math' orientation rather than 'geo') and convert things when displaying debug information..

I recommend Wolfram's resources: http://mathworld.wolfram.com
They're thick, but I know of no better online resource.

I have to disagree with the recommendation of Physics for Game Developers.
I found that book pretty boring, and I wouldn't call my own attention span that short.
I would say the top things to get good at are vectors, using trig to manipulate them, and then on top of that foundation you apply whatever physics are specific to your current project.
I'd just fire up google/wikipedia and start bouncing around the web soaking up random stuff, and when your limited attention span gets antsy, bounce again.
Taking on that book is probably not going to suck you in and inspire you.

GameDev.net has a section of articles for Math and Physics coding. It's worth a quick look through to see if anything is related to what you're trying to do.
http://www.gamedev.net/reference/list.asp?categoryid=28

If you want a general math website I'd recommend planetmath.org.  The articles there tend to hold a higher standard than wikipedia (which in my experience can be downright appalling when it comes to math) and are more user friendly than mathworld.  Mathworld is good if you are a mathematician and need the complete correct definition of some term, but for day to day use it tends to be far to theoretical and obtuse. 

If you live in the US, how about enrolling at a local community college to take those math classes you missed? They will have resources available to help students who need remedial skills classes and may have a learning disability. You have an incentive to learn and you now realize the value of the education. There's no shame in wanting to learn. See an academic counselor and they'll help you out. Go for it.

You might want to check out any OReilly text on the topic. They have good examples that you can work through. This will give you a better idea of if programming is right for you. If you want to get into game programming, best way is to actually start game programming. Just go at it and look up answers to questions (links in other replies here) as they arise.

I very much believe that learning from Videos series is the fastest way ever possible for learning, that is, if you wanna move fast with the thing that you're willing to learn.
You could spend a lot of time reading a page just to get a small piece of info that a video could give you in a minute or two!
And for that, I found this Math channel:
https://www.youtube.com/user/patrickJMT
Also:
https://www.youtube.com/playlist?list=PL233FC7AA6FE11E0E

You can start out by learning Processing!
Then move onto this amazing book by Daniel Shiffman called 'The Nature of Code'. The book is also available online with interactive examples written in Processing.js
http://natureofcode.com/book/
The book covers
1. VECTORS
2. FORCES
3. OSCILLATION
4. PARTICLE SYSTEMS
5. PHYSICS LIBRARIES
6. AUTONOMOUS AGENTS
7. CELLULAR AUTOMATA
8. FRACTALS
9. THE EVOLUTION OF CODE
10. NEURAL NETWORKS

He also has uploaded videos to Vimeo explaining concepts from each chapter!
http://vimeo.com/shiffman/videos/sort:date/format:detail

How can we capture the unpredictable evolutionary and emergent
  properties of nature in software? How can understanding the
  mathematical principles behind our physical world help us to create
  digital worlds? This book focuses on the programming strategies and
  techniques behind computer simulations of natural systems using
  Processing.

He has also written a book to teach you the basics of Learning processing
http://www.learningprocessing.com/

This book tells a story. Itâs a story of liberation, of taking the
  first steps towards understanding the foundations of computing,
  writing your own code, and creating your own media without the bonds
  of existing software tools. This story is not reserved for computer
  scientists and engineers. This story is for you.

