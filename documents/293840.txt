Is there a fast way to transfer all the variables of one identical object into another in C#?
c# oop
This is probably a simple question.  Suppose I have a object called Users and it contains a lot of protected variables. 
Inside that Users class I have a method that creates a temporary Users object, does something with it, and if successful, transfers all the variables from the temp Users object into the one I have.  
Is there some fast way to transfer all the variables from one Users object into another Users object without doing this using C#?
this.FirstName = temp.FirstName;
this.LastName = temp.LastName;
........75 variables later......
this.FavoriteColor = temp.FavoriteColor



A better approach is to implement the IClonable interface. But you'll find it doesn't save you a lot of work.

You should check out cloning in C#.
http://stackoverflow.com/questions/78536/cloning-objects-in-c

A better solution might be to move whatever this method is outside of your class, and then just assign the temp user object to your main user object reference like so:
_User = tmpUser;

sparing you the 75 lines of code.  Whenever I have a class creating an instance of itself inside one of its own methods, I always like to blink a couple of times and make sure I really need to be doing that.

I think serializing and then deserializing an object will create a new object instance. This should be identical to the former object.

There's always the reflection option. Something substantially similar to this:
public static void Copy(object source, object target)
    {
        foreach (System.Reflection.PropertyInfo pi in source.GetType().GetProperties())
        {
            System.Reflection.PropertyInfo tpi = target.GetType().GetProperty(pi.Name);
            if (tpi != null && tpi.PropertyType.IsAssignableFrom(pi.PropertyType))
            {
                tpi.SetValue(target, pi.GetValue(source, null), null);
            }

        }
    }

Doesn't require the source and the target to have any relation what-so-ever, just a name and an IsAssignable check. It has the interesting side effects if you're using reference types anywhere, but for the kind of situation you just described, this isn't a bad option to explore.
class sourceTester
{
    public bool Hello { get; set; }
    public string World { get; set; }
    public int Foo { get; set; }
    public List<object> Bar { get; set; }
}

class targetTester
{
    public int Hello {get; set;}
    public string World { get; set; }
    public double Foo { get; set; }
    public List<object> Bar { get; set; }
}

static void Main(string[] args)
    {


        sourceTester src = new sourceTester { 
            Hello = true, 
            World = "Testing",
            Foo = 123,
            Bar = new List<object>()
        };

        targetTester tgt = new targetTester();

        Copy(src, tgt);

        //Immediate Window shows the following:
        //tgt.Hello
        //0
        //tgt.World
        //"Testing"
        //tgt.Foo
        //0.0
        //tgt.Bar
        //Count = 0
        //src.Bar.GetHashCode()
        //59129387
        //tgt.Bar.GetHashCode()
        //59129387
    }

