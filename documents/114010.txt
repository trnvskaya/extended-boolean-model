Create anonymous object by Reflection in C#
c# silverlight reflection anonymous-objects
Is there any way to create C# 3.0 anonymous object via Reflection at runtime in .NET 3.5? I'd like to support them in my serialization scheme, so I need a way to manipulate them programmatically.
edited later to clarify the use case
An extra constraint is that I will be running all of it inside a Silverlight app, so extra runtimes are not an option, and not sure how generating code on the fly will work.


Use reflection to get the Type, use GetConstructor on the type, use Invoke on the constructor.
Edit:  Thanks to Sklivvz for pointing out that I answered a question that wasn't asked ;)
The answer to the actual question: I've found that generating C# code and then using CodeDomProvider (but not CodeDOM itself -- terrible) and then compiling that down and reflecting types out of that is the easiest way of doing 'anonymous' objects at runtime.

You might want to look into the DLR. I havn't done so myself (yet) but the use-case for the DLR (dynamic languages) sounds a lot like what you're trying to do.
Depending on what you want to do the Castle-framework's dynamic proxy object might be a good fit too.

Yes, there is.
From memory:
public static T create<T>(T t)
{
    return Activator.CreateInstance<T>();
}

object anon = create(existingAnonymousType);


You can use Reflection.Emit to generate the required classes dynamically, although it's pretty nasty to code up.
If you decide upon this route, I would suggest downloading the Reflection Emit Language Addin for .NET Reflector, as this allows you to see how existing classes would be built using Reflection.Emit, hence a good method for learning this corner of the framework.

You might also want to have a look into the FormatterServices class: MSDN entry on FormatterServices
It contains GetSafeUninitializedObject that will create an empty instance of the class, and several other handy methods when doing serialization.
In reply to comment from Michael:
If you don't have the Type instance for type T, you can always get it from typeof(T). If you have an object of an unknown type, you can invoke GetType() on it in order to get the Type instance.

Here is another way, seems more direct.
object anon = Activator.CreateInstance(existingObject.GetType());

