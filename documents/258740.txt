What tools are built using themselves?
bootstrapping
I am curious about what tools are used to build the next version of themselves.
For example, Delphi has long claimed that "Delphi is written in Delphi".
I assume Visual Studio is written using Visual Studio.
What are some other examples of tools that written in themselves?


Generically speaking, C compilers are usually written in C...  *nix kernels are compiled on *nix, etc.

Interestingly, the VB.NET & C# compilers themselves are written in unmanaged C++ (leading to the C++ team's T-Shirt: "My compiler compiled yours").  The C# team hopes to have a fully managed-C# hosted C# compiler for VS2010.

Visual Studio and Team Foundation Server build themselves.   It's called dogfooding, a term which if not originating in Microsoft, it certainly likes

Maven2 is built using Maven2.
Ok, it's not built (i.e. written) using itself, as it is a tool to build (i.e. compile) project, but it is using its own code to compile...

When gcc (the Gnu C compiler http://gcc.gnu.org/) was not available widely, you had to compile it from source, compiling stage1 compiler, then compile stage2 with stage1, till you have your final compiler. I assume it must be the same today.

Lots of folks like to look at how Lisp can be implemented in Lisp.

Also, there's the pypy project which provides a Python interpreter written in Python.

We use to develop using RealBasic.  The IDE is written in itself, or so I've been lead to believe.

Here is another example: Mono's C# compiler is self hosting - i.e. it's written in C# and used to compile itself.
Dog fooding refers to the more general practice of a company using its own product internally, especially during its development.

Bjarne Stroustrup mentioned in The Design and Evolution of C++ that the first C++ compiler was written in C++.
I've just noticed this is also a question in his FAQ:

The first C++ compiler (Cfront) was
  written in C++. To build that, I first
  used C to write a "C with
  Classes"-to-C preprocessor. "C with
  Classes" was a C dialect that became
  the immediate ancestor to C++. That
  preprocessor translated "C with
  Classes" constructs (such as classes
  and constructors) into C. It was a
  traditional preprocessor that didn't
  understand all of the language, left
  most of the type checking for the C
  compiler to do, and translated
  individual constructs without complete
  knowledge. I then wrote the first
  version of Cfront in "C with Classes".


ghc, the Haskell compiler, is mostly written in Haskell.

Oracle Application Express is a web application development tool that is built in itself.

This is off-topic, but strictly speaking, it is an example of a tool which builds itself.
The reprap - an open-source 3d prototyping machine, which recently gave 'birth' to "its first complete working replicated copy".
I love this kind of stuff.

I was amazed with JSLint 
In short it has been described as Javascript "compiler" using javascript.

I am building an IDE-based code generator, and I am using it to build itself. If fact, as Stroustrup did, I am first building a valid generator model and using a pre-processor to build the final C++ code to compile. Once I have a good working version of the IDE, I'll start using it to build further versions of itself.
It's like giving a new dimension to the meaning of "recursive programming"!

AFAIK does the OpenJDK build itself first with the installed java and afterwards with itself.

Naturally the Jetbrains team uses its own IDE IntelliJ IDEA to develop this IDE.
I assume this is true for most IDE vendors.

As far as I know, when building EMACS from source, all of the ELISP code is bootstrapped. I found that quite noteworthy.

Not quite what you're asking for, but the entire development environment for Revolution http://www.runrev.com is built using Revolution itself, and the source (except for small parts that enforce the license) is completely exposed in source form. So if you don't like the way the dev environment is implemented, you can change it. Find a bug, fix it. You can also easily build additional development tools and integrate them.

Eclipse IDE is generally built and developed using Eclipse IDE.

Squeak is a Smalltalk-80 implementation written in itself.

even its virtual machine is written entirely in Smalltalk making it easy to debug, analyze, and change.


I gave the Smalltalk-80 answer an uptick. Best, most elegant example I can think of. The question also reminds me of a slightly related problem that used to be popular: write a program that outputs itself. Not the same level of bootstrapping, but a fun little programming puzzle for your amusement. Maybe not possible in all languages?

Ada and Forth

The old Watcom C/C++ compiler was built using itself.

Sun's Java compiler has long been written in Java. However, recent work is writing a JIT compiler in Java as well. This is the JVM component that converts Java byte code to native processor instructions.

Kragen Sitaker's Ur-Scheme is a fine example of a small nontrivial compiler written in itself. That page links to several more good sources in that vein.

tcc is another self-hosting C compiler for x86 and ARM. Its claim to fame is being, well, tiny (100k or so for preprocessor, compiler, assembler, and linker).

I would assume that pretty much any tool that's part of the typical development process would be involved in its own development, to whatever extent possible. This includes:

certain programming languages, especially compiled ones
IDEs
text editors
version control systems
bug trackers
build systems

If you're on a team building one of these tools, and you're not developing it for a specific niche that doesn't apply to your team, I don't know why you wouldn't use it to build itself. Having developers be users of the product is one of the best ways to find possible improvements.

I'm developing an Eclipse plugin called nWire which assists and accelerates code exploration. I've been using it as part of my development since the moment it was stable enough and I just can't live without it now (well, it has the tendency of becoming a habit very quickly :-).
For me it's "eat your own dog food", but it really helps. This also raises my confidence in the product.

For the AmigaOS there was a third party Basic interpreter (don't remember the name) for which you could later buy a compiler. The compiler was delivered as source, so you had to use the interpreter to run the compiler to compile itself...
To cite Kent Beck: 

...it may seem a bit like performing brain surgery on yourself.


It is fairly typical to have a languages compiler written in its own language.  This is called self-hosting or bootstrapping.

That's the way most compilers work. Yes, I know, there are exceptions, but it might actually be shorter to list those exceptions.
In the meantime, I know that gnat requires an Ada compiler (gnat will do) to compile from sources. GCC requires some kind of C compiler, and has a bootstrap phase to build itself using itself (or at least it did 15 years ago when last I went through that pain). The creator of Draco I belive told me that it was written in Draco.
