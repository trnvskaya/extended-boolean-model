.Access violation reading location
c++ boost smart-pointers access-violation
I've met a really strange problem.
The code is as follow:
::boost::shared_ptr<CQImageFileInfo> pInfo=CQUserViewDataManager::GetInstance()->GetImageFileInfo(nIndex); 
Image* pImage=pInfo->m_pThumbnail;
if(pImage==NULL)
    pImage=m_pStretchedDefaultThumbImage;
else
{
    //
    int sourceWidth  = pInfo->GetWidth();
    int sourceHeight = pInfo->GetHeight();

    int destX = 0,
        destY = 0; 

    float nPercent  = 0;
    float nPercentW = ((float)GetThumbImageWidth()/(float)sourceWidth);;
    float nPercentH = ((float)GetThumbImageHeight()/(float)sourceHeight);

    if(nPercentH < nPercentW)
    {
        nPercent = nPercentH;
        destX    = (int)((GetThumbImageWidth() - (sourceWidth * nPercent))/2);
    }
    else
    {
        nPercent = nPercentW;
        destY    = (int)((GetThumbImageHeight() - (sourceHeight * nPercent))/2);
    }

    int destWidth  = (int)(sourceWidth * nPercent);
    int destHeight = (int)(sourceHeight * nPercent);
    rcShowImage=CRect(rc.left+destX, rc.top+destY,rc.left+destX+destWidth,rc.top+destY+destHeight);
}
ASSERT(pImage != NULL); // passed assertion...
graphics.DrawImage(pImage,rcShowImage.left,rcShowImage.top,
rcShowImage.Width(),rcShowImage.Height()); // problem happened here.

I received the following exception:
First-chance exception at 0x004095b0 in ec.exe: 0xC0000005: Access violation reading location 0xfeeefef2.
Unhandled exception at 0x004095b0 in ec.exe: 0xC0000005: Access violation reading location 0xfeeefef2.

I have checked the pImage, I am sure when graphics.DrawImage is called, it is not NULL.

why such a problem happened?
What is 0xfeeefef2?



What happens if pImage == NULL on the third line you pasted? In that case, rcShowImage is not assigned a value.

When you do
pImage=m_pStretchedDefaultThumbImage;

Is there a possibility that m_pStretchedDefaultThumbImage is uninitialized?

0xfeeefeee is a fill pattern that the debug version of the Windows heap (not the C runtime heap) uses for uninitialized memory. 0xfeeefef2 is 0xfeeefeee+4. It sounds like you're dereferencing an uninitialized pointer located in (or copied from) a block of memory allocated from the heap.
The debug heap automatically gets enabled when you start your program in the debugger, as opposed to attaching to an already-running program with the debugger.
The book Advanced Windows Debugging by Mario Hewardt and Daniel Pravat has some decent information about the Windows heap, and it turns out that the chapter on heaps is up on the web site as a sample chapter.
