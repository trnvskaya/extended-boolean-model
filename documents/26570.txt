sizeof() equivalent for reference types?
c# .net
I'm looking for a way to get the size of an instance of a reference type. sizeof is only for value types. Is this possible?


You need Marshal.SizeOf
Edit: This is for unsafe code, but then, so is sizeof().

Beware that Marshal.SizeOf is for unsafe code...
I don't think it's possible for managed code though, maybe you can explain your problem, there may be another way to solve it

If you don't mind it being a little less accurate than perfect, and for comparative purposes, you could serialize the object/s and measure that (in bytes for example)
EDIT (I kept thinking after posting): Because it's a little more complicated than sizeof for valuetypes, for example: reference types can have references to other objects and so on... there's not an exact and easy way to do it that I know of...

If you can - Serialize it!
Dim myObjectSize As Long

Dim ms As New IO.MemoryStream
Dim bf As New Runtime.Serialization.Formatters.Binary.BinaryFormatter()
bf.Serialize(ms, myObject)
myObjectSize = ms.Position


I had a similar question recently and wanted to know the size of Object and LinkedListNode in C#. To solve the problem, I developed a program that would:

Measure the program's "Working Set"
Allocate a lot of objects.
Measure the "Working Set" again.
Divide the difference by the number of allocated objects.

On my computer (64-bit), I got the following data:
Measuring Object:
iter    working set     size estimate
-1      11190272
1000000 85995520        74.805248
2000000 159186944       73.998336
3000000 231473152       73.4276266666667
4000000 306401280       73.802752
5000000 379092992       73.580544
6000000 451387392       73.3661866666667
7000000 524378112       73.3125485714286
8000000 600096768       73.613312
9000000 676405248       73.9127751111111
Average size: 73.7577032239859
Measuring LinkedListNode<Object>:
iter    working set     size estimate
-1      34168832
1000000 147959808       113.790976
2000000 268963840       117.397504
3000000 387796992       117.876053333333
4000000 507973632       118.4512
5000000 628379648       118.8421632
6000000 748834816       119.110997333333
7000000 869265408       119.299510857143
8000000 993509376       119.917568
9000000 1114038272      119.985493333333
Average size: 118.296829561905
Estimated Object size: 29.218576886067
Estimated LinkedListNode<reference type> size: 44.5391263379189

Based on the data, the average size of allocating millions of Objects is approximately 29.2 bytes. A LinkedListNode object is approximately 44.5 bytes. This data illustrates two things:

It's very unlikely that the system is allocating a partial byte. The fractional measure of bytes indicates the overhead the CLR requires to allocate and track millions of reference types.
If we simply round-down the number of bytes, we're still unlikely to have the proper byte count for reference types. This is clear from the measure of Objects. If we round down, we assume the size is 29 bytes which, while theoretically possible, is unlikely because of padding. In order to improve performance, object allocations are usually padded for alignment purposes. I would guess that CLR objects will be 4 byte aligned.

Assuming CLR overhead and 4-byte alignment, I'd estimate an Object in C# is 28 bytes and a LinkedListNode is 44 bytes.
BTW Jon Skeet had the idea for the method above before I did and stated it in this answer to a similar question.

Please refer my answer in the below link.
It is possible via .sos.dll debugger extension
Find out the size of a .net object
