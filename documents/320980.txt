Steps in the memory allocation process for Java objects
java memory object heap
What happens in the memory when a class instantiates the following object? 
public class SomeObject{

    private String strSomeProperty;

    public SomeObject(String strSomeProperty){
        this.strSomeProperty = strSomeProperty;
    }
    public void setSomeProperty(String strSomeProperty){
        this.strSomeProperty = strSomeProperty;
    }
    public String getSomeProperty(){
        return this.strSomeProperty;
    }
}

In class SomeClass1:
SomeObject so1 = new SomeObject("some property value");

In class SomeClass2:
SomeObject so2 = new SomeObject("another property value");

How is memory allocated to the newly instantiated object and its properties? 


Googled for "Java Memory Management" and got this - http://www.javaworld.com/javaworld/javaqa/1999-08/04-qa-leaks.html 

Let's step through it:
SomeObject so1 = new SomeObject("some property value");

... is actually more complicated than it looks, because you're creating a new String. It might be easier to think of as:
String tmp = new String("some property value");
SomeObject so1 = new SomeObject(tmp);
// Not that you would normally write it in this way.

(To be absolutely accurate - these are not really equivalent. In the original the 'new String' is created at compile time and is part of the .class image. You can think of this as a performance hack.)
So, first the JVM allocates space for the String. You typically don't know or care about the internals of the String implementation, so just take it on trust that a chunk of memory is being used to represent "some property value". Also, you have some memory temporarily allocated containing a reference to the String. In the second form, it's explicitly called tmp; in your original form Java handles it without naming it.
Next the JVM allocates space for a new SomeObject. That's a bit of space for Java's internal bookkeeping, and space for each of the object's fields. In this case, there's just one field, strSomeProperty.
Bear in mind that strSomeProperty is just a reference to a String. For now, it'll be initialised to null.
Next, the constructor is executed. 
this.strSomeProperty = strSomeProperty;

All this does is copy the reference to the String, into your strSomeProperty field.
Finally, space is allocated for the object reference so1. This is set with a reference to the SomeObject.
so2 works in exactly the same way.


Read about the JVM Stack and Heap.
Read about references, how Java passes by reference and what this really means.
Read about what happens when you use a String literal in Java, and how Strings are handled slightly differently to other objects in the heap (In a String-specifc section of the Heap).
Read about what happens when you use the new keyword.

Once you understand these things, you'll be able to answer your own question.


Determining Memory Usage in Java by Dr. Heinz M. Kabutz gives a precise answer, plus a program to calculate the memory usage.  The relevant part:


The class takes up at least 8 bytes. So, if you say new Object(); you will allocate 8 bytes on the heap.
Each data member takes up 4 bytes, except for long and double which take up 8 bytes. Even if the data member is a byte, it will still take up 4 bytes! In addition, the amount of memory used is increased in 8 byte blocks. So, if you have a class that contains one byte it will take up 8 bytes for the class and 8 bytes for the data, totalling 16 bytes (groan!).
Arrays are a bit more clever. Primitives get packed in arrays, so if you have an array of bytes they will each take up one byte (wow!). The memory usage of course still goes up in 8 byte blocks. 


As people have pointed out in the comments, Strings are a special case, because they can be interned.  You can reason about the space they take up in the same way, but keep in mind that what looks like multiple copies of the same String may actually point to the same reference.

Points to remember:

When a method is called, a frame is created on the top of stack.  
Once a method has completed execution, flow of control returns to the calling method and its corresponding stack frame is flushed.  
Local variables are created in the stack.  
Instance variables are created in the heap & are part of the object they belong to.  
Reference variables are created in the stack.

Ref: http://www.javatutorialhub.com/java-stack-heap.html
