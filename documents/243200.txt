What are some useful PHP Idioms?
php conventions
I'm looking to improve my PHP coding and am wondering what PHP-specific techniques other programmers use to improve productivity or workaround PHP limitations.
Some examples:

Class naming convention to handle namespaces: Part1_Part2_ClassName maps to file Part1/Part2/ClassName.php
if ( count($arrayName) ) // handles $arrayName being unset or empty
Variable function names, e.g. $func = 'foo'; $func($bar); // calls foo($bar);



My experience with PHP has taught me a few things. To name a few:

Always output errors. These are the first two lines of my typical project (in development mode):

ini_set('display_errors', '1');
error_reporting(E_ALL);

Never use automagic. Stuff like autoLoad may bite you in the future.
Always require dependent classes using require_once. That way you can be sure you'll have your dependencies straight.
Use if(isset($array[$key])) instead of if($array[$key]). The second will raise a warning if the key isn't defined.
When defining variables (even with for cycles) give them verbose names ($listIndex instead of $j)
Comment, comment, comment. If a particular snippet of code doesn't seem obvious, leave a comment. Later on you might need to review it and might not remember what it's purpose is.

Other than that, class, function and variable naming conventions are up to you and your team. Lately I've been using Zend Framework's naming conventions because they feel right to me.
Also, and when in development mode, I set an error handler that will output an error page at the slightest error (even warnings), giving me the full backtrace.

Fortunately, namespaces are in 5.3 and 6. I would highly recommend against using the Path_To_ClassName idiom. It makes messy code, and you can never change your library structure... ever.
The SPL's autoload is great. If you're organized, it can save you the typical 20-line block of includes and requires at the top of every file. You can also change things around in your code library, and as long as PHP can include from those directories, nothing breaks.
Make liberal use of === over ==. For instance:
if (array_search('needle',$array) == false) {
  // it's not there, i think...
}

will give a false negative if 'needle' is at key zero. Instead:
if (array_search('needle',$array) === false) {
  // it's not there!
}

will always be accurate.

See this question: Hidden Features of PHP. It has a lot of really useful PHP tips, the best of which have bubbled up to the top of the list.

I've been developing with PHP (and MySQL) for the last 5 years. Most recently I started using a framework (Zend) with a solid javascript library (Dojo) and it's changed the way I work forever (in a good way, I think).
The thing that made me think of this was your first bullet: Zend framework does exactly this as it's standard way of accessing 'controllers' and 'actions'.
In terms of encapsulating and abstracting issues with different databases, Zend_Db this very well. Dojo does an excellent job of ironing out javascript inconsistencies between  different browsers.
Overall, it's worth getting into good OOP techniques and using (and READING ABOUT!) frameworks has been a very hands-on way of getting to understand OOP issues.
For some standalone tools worth using, see also:
Smarty (template engine)
ADODB (database access abstraction)

There are a few things I do in PHP that tend to be PHP-specific.

Assemble strings with an array.
A lot of string manipulation is expensive in PHP, so I tend to write algorithms that reduce the discrete number of string manipulations I do. The classic example is building a string with a loop. Start with an array(), instead, and do array concatenation in the loop. Then implode() it at the end. (This also neatly solves the trailing-comma problem.)
Array constants are nifty for implementing named parameters to functions.


Ultimately, you'll get the most out of PHP first by learning generally good programming practices, before focusing on anything PHP-specific.  Having said that...

Apply liberally for fun and profit:

Iterators in foreach loops.  There's almost never a wrong time.
Design around class autoloading.  Use spl_autoload_register(), not __autoload().  For bonus points, have it scan a directory tree recursively, then feel free to reorganize your classes into a more logical directory structure.
Typehint everywhere.  Use assertions for scalars.
function f(SomeClass $x, array $y, $z) {
    assert(is_bool($z))
}

Output something other than HTML.
header('Content-type: text/xml'); // or text/css, application/pdf, or...

Learn to use exceptions.  Write an error handler that converts errors into exceptions.
Replace your define() global constants with class constants.
Replace your Unix timestamps with a proper Date class.
In long functions, unset() variables when you're done with them.


Use with guilty pleasure:

Loop over an object's data members like an array.  Feel guilty that they aren't declared private.  This isn't some heathen language like Python or Lisp.
Use output buffers for assembling long strings.
ob_start();
echo "whatever\n";
debug_print_backtrace();
$s = ob_get_clean();



Avoid unless absolutely necessary, and probably not even then, unless you really hate maintenance programmers, and yourself:

Magic methods (__get, __set, __call)
extract()
Structured arrays -- use an object


Declare variables before using them!


Enable NOTICE, and if you realy want to STRICT error reporting. It prevents a lot of errors and code smell: ini_set('display_errors', 1); error_reporting(E_ALL && $_STRICT);
Stay away from global variables
Keep as many functions as possible short. It reads easier, and is easy to maintain. Some people say that you should be able to see the whole function on your screen, or, at least, that the beginning and end curly brackets of loops and structures in the function should both be on your screen
Don't trust user input!


Thanks all for your answers. There is a some very helpful stuff here.
I have a slight issue with the point about namespaces (and not using the Path_To_ClassName approach) because the feature has taken a long time to arrive IMO and 5.3 alpha1 isn't production ready yet. So the rest of us have been making do with whatever works in the meantime. Better late than never, though.
Clearly, there isn't any one right answer to this question, but I'm going to vote up all the answers so far (assuming the site lets me).

Get to know the different types and the === operator, it's essential for some functions like strpos() and you'll start to use return false yourself.
