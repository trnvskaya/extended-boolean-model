Windsor Interceptors AOP & Caching
.net castle-windsor aop
I'm considering using Castle Windsor's Interceptors to cache data for helping scale an asp.net site.
Does anyone have any thoughts/experience with doing this?
Minor clarification:
My intention was to use Windsor to intercept 'expensive' calls and delegate to MemCacheD or Velocity (or another distributed cache) for the caching itself.


Windsor is great, but why use that for caching when you have several built in ways to cache data. Windsor has its foundation in other areas not necessarily caching. From the cache object to session to cookies. There are many ways to cache. More importantly in large applications you end up needing distributed caching. MS is working on a product for that and there are a couple good vendors out there that have products on the market. 

I'd look at the Microsoft Velocity. If you plan on creating an Enterprise application, this might be a good solution

How are you implementing your data access?  If your using NHibernate, I would suggest caching here.  NHibernate comes with cache strategies for the .NET built-in cache, memcached (via NMemcachD) and Velocity.  I've used memcached extensivly for enterprise level applications and have not had a problem with it.
An intercepter based caching mechanism is an interesting idea, one I haven't thought of before.  It would be very easy to transparently apply.  The one think I love about using the AOP features of Castle is because it's proxy based, you don't have to pollute your code with attributes.

I've been using caching decorators (not interceptors) with Windsor and they work great.
Interceptors are good for this as well, see this for example.

Hey there, We've used Castle Windsor Interceptors, based on this article: http://www.davidhayden.com/blog/dave/archive/2007/03/14/CastleWindsorAOPPolicyInjectionApplicationBlock.aspx as well as the one mentioned above.
I found the whole thing pretty easy and it's a very elegant way to do AOP. However....
Careful with the performance though. Using interception creates a dynamic proxy that will definitely slow things down. Based on our benchmarks using a 500 Node computing farm we saw a performance decrease of about 30% by using interception in Windsor, this was outside what we were doing inside the interception as well (essentially logging method calls and params passed in to our methdods). and simply removing the interception sped the whole app up quite a bit. 
Careful you don't make your expensive calls really expensive. :) If I were you I would look to cache at a different level, probably by implementing an IRepository type pattern and then backing that with various caching strategies where appropriate. 
Good luck, 
--
Matt. 

I created on open source project named cachew.castlewindsor with a caching interceptor.
It is a general purpose solution for caching.
Here is a simple example of usage:
var container = new WindsorContainer();
container.Register(Component.For<CacheInterceptor>()
  .Instance(new CacheInterceptor(new Cache(TimeoutStyle.RenewTimoutOnQuery, TimeSpan.FromSeconds(3)))));
container.Register(Component.For<IServer>().ImplementedBy<Server>().Interceptors<CacheInterceptor>());
The default behaviour is to cache all methods that starts with Get and return data, but you can also change what prefixes to cache.
The project is available on nuget: 
http://www.nuget.org/packages/Cachew.CastleWindsor/
And the source code is available here:
https://github.com/kobbikobb/Cachew
