How to determine which Child Page is being displayed from Master Page?
c# asp.net master-pages
I'm writing code on the master page, and I need to know which child (content) page is being displayed.  How can I do this programmatically? 


You can use:
Request.CurrentExecutionFilePath

Page.Request.Url.PathAndQuery or one of the other properties of the Url Uri object should be available to you from the master page code.

I do something similar to this in a project of mine to dynamically attach css files based on the page being loaded.  I just get the name of the file from the request:
this.Request.Url.AbsolutePath

And then extract the file name from there.  I'm not sure if this will work if you are doing URL re-writes though.

This sounds like a bad idea to start with. The idea of the master is that it shouldn't care what page is there as this is all common code for each page.

You can check the page type in the code-behind:
// Assuming MyPage1, MyPage2, and MyPage3 are the class names in your aspx.cs files:

if (this.Page is MyPage1)
{
  // do MyPage1 specific stuff
}
else if (this.Page is MyPage2)
{
  // do MyPage2 specific stuff
}
else if (this.Page is MyPage3)
{
  // do MyPage3 specific stuff
}


It's better to let the ContentPage notify the MasterPage. That's why the ContentPage has a Master Property and MasterPage does not have Child property.
Best pratice in this is to define a property or method on the MasterPage and use this through the Master property of the ContentPage.
If you use this technique it's best to explicitly specify  the classname for the MasterPage. This makes to use the MasterPage in the ContentPage.
Example:
//Page_Load
MyMaster m = (MyMaster)this.Master;

m.TellMasterWhoIAm(this);

Hope this helps.

I use this:
string pageName = this.ContentPlaceHolder1.Page.GetType().FullName;

It retuns the class name in this format "ASP.default_aspx", but I find that easy to parse for most purposes.
Hope that helps!

I have had a reason to check the child page in the master page.
I have all my menu options on my master page and they need to be disabled if certain system settings are not set up. 
If they are not then a message is displayed and the buttons are disabled. As the settings page  is a content page from this master page I don't want the message to keep being displayed on all the settings pages.
this code worked for me:
                //Only show the message if on the dashboard (first page after login)
                if (this.ContentPlaceHolder1.Page is Dashboard)
                {
                    //Show modal message box
                    mmb.Show("Warning Message");
                }


You can do this by getting the last segmant or the request and I'll be the Form name
string pageName = this.Request.Url.Segments.Last(); 

if (pageName.Contains("EmployeeTermination.aspx"))
{

}


Use the Below code. 
Page.ToString().Replace("ASP.","").Replace("_",".")


You can try this one:

<%: this.ContentPlaceHolder1.Page.GetType().Name.Split('_')[0].ToUpper() %>

Put that code within the title tags of the Site.Master

Request.CurrentExecutionFilePath;

or
Request.AppRelativeCurrentExecutionFilePath;


string s =   Page.ToString().Replace("ASP.directory_name_","").Replace("_aspx",".aspx").Replace("_","-");
        if (s == "default.aspx")
              { /* do something */ }


Here is my solution to the problem (this code goes into the code behind the master page):
if (Page.TemplateControl.AppRelativeVirtualPath == "~/YourPageName.aspx")
{
   // your code here
}

or a bit more sophisticated, but less readable:
if (Page.TemplateControl.AppRelativeVirtualPath.Equals("~/YourPageName.aspx", StringComparison.OrdinalIgnoreCase))
{
   // your code here
}


so many answers I am using 
<%if(this.MainContent.Page.Title != "mypagetitle") { %>
<%}%>

this makes it easy to exclude any single page and since your comparing a string you could even prefix pages like exclude_pagetitle and comparing a sub-string of the title. I use this commonly to exclude log in pages from certain features I don't want to load like session timeouts and live chat. 
