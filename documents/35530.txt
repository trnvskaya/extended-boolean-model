What Are High-Pass and Low-Pass Filters?
algorithm graphics audio photoshop signal-processing
Graphics and audio editing and processing software often contain functions called "High-Pass Filter" and "Low-Pass Filter".  Exactly what do these do, and what are the algorithms for implementing them?


Wikipedia:

High-pass filter
Low-pass filter
Band-pass filter

These "high", "low", and "band" terms refer to frequencies. In high-pass, you try to remove low frequencies. In low-pass, you try to remove high. In band pass, you only allow a continuous frequency range to remain.
Choosing the cut-off frequency depends upon your application. Coding these filters can either be done by simulating RC circuits or by playing around with Fourier transforms of your time-based data. See the wikipedia articles for code examples.

They are generally Electrical circuits that tend to pass parts of analog signals. High pass tends to transmit more of the high frequency parts and low pass tends to pass more of the low frequency parts.
They can be simulated in software. A walking average can act as a low pass filter for instance and the difference between a walking average and it's input can work as a high pass filter.

High-pass filter lets high-frequency (detailed/local information) pass.
Low-pass filter lets low-frequency (coarse/rough/global information) pass.

Here is how you implement a low-pass filter using convolution:
double[] signal = (some 1d signal);
double[] filter = [0.25 0.25 0.25 0.25]; // box-car filter
double[] result = new double[signal.Length + filter.Length + 1];

// Set result to zero:
for (int i=0; i < result.Length; i++) result[i] = 0;

// Do convolution:
for (int i=0; i < signal.Length; i++) 
  for (int j=0; j < filter.Length; j++)
    result[i+j] = result[i+j] + signal[i] * filter[j];

Note that the example is extremely simplified. It does not do range checks and does not handle the edges properly. The filter used (box-car) is a particularly bad lowpass filter, because it will cause a lot of artifacts (ringing). Read up on filter design.
You can also implement the filters in the frequency domain. Here is how you implement a high-pass filter using FFT:
double[] signal = (some 1d signal);
// Do FFT:
double[] real;
double[] imag;
[real, imag] = fft(signal)

// Set the first quarter of the real part to zero to attenuate the low frequencies
for (int i=0; i < real.Length / 4; i++) 
  real[i] = 0;

// Do inverse FFT:
double[] highfrequencysignal = inversefft(real, imag);

Again, this is simplified, but you get the idea. The code does not look as complicated as the math.

Filtering describes the act of processing data in a way that applies different levels of attenuation to different frequencies within the data.
A high pass filter will apply minimal attentuation (ie. leave levels unchanged) for high frequencies, but applies maximum attenuation to low frequencies.
A low pass filter is the reverse - it will apply no attenuation to low frequencies by applies attenuation to high frequencies.
There are a number of different filtering algorithms that are used. The two simplest are probably the Finite Impulse Response filter (aka. FIR filter) and the Infinite Impulse Response filter (aka. IIR filter).
The FIR filter works by keeping a series of samples and multiplying each of those samples by a fixed coefficient (which is based on the position in the series). The results of each of these multiplications is accumulated and is the output for that sample. This is referred to as a Multiply-Accumulate - and in dedicated DSP hardware there is a specific MAC instruction for doing just this.
When the next sample is taken it's added to the start of the series, and the oldest sample in the series is removed, and the process repeated.
The behavior of the filter is fixed by the selection of the filter coefficients.
One of the simplest filters that is often provided by image processing software is the averaging filter. This can be implemented by an FIR filter by setting all of the filter coefficients to the same value.

Here is a super simple example of a low pass filter in C++ that processes the signal one sample at a time:
float lopass(float input, float cutoff) {
 lo_pass_output= outputs[0]+ (cutoff*(input-outputs[0])); 
outputs[0]= lo_pass_output;
return(lo_pass_output);
}

Here is pretty much the same thing, except it's high pass:
float hipass(float input, float cutoff) {
 hi_pass_output=input-(outputs[0] + cutoff*(input-outputs[0]));
 outputs[0]=hi_pass_output;
 return(hi_pass_output);
}

