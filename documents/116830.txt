Is there an "anonymous" generic tag in C#, like '?' in Java?
c# generics syntax
In Java, one can declare a variable parameterised by an "unknown" generic type, which looks like this:
Foo<?> x;

Is there an equivalent construct to this question-mark, in C#?


No, there isn't really the same concept in C#.  You would need to refer to a base class of Foo (maybe a non-generic Foo), or make the method you're working in generic itself (so that you can refer to Foo, and let the caller of your method determine what T is).
Hope that helps.

There isn't an equivalent syntax in C#.

AFAIK you can not do that in C#. What the BCL does and there are plenties of examples there is to create a class that is not generic and then create a generic class that inherits the base behavior from the previous one. See example below.
class Foo
{
}

class Foo<T> : Foo
{
}

The you can write something like this:
Foo t = new Foo<int>();


From C# from a Java developer's perspective by Dare Obasanjo:
In certain cases, one may need create a method that can operate on data structures containing any type as opposed to those that contain a specific type (e.g. a method to print all the objects in a data structure) while still taking advantage of the benefits of strong typing in generics. The mechanism for specifying this in C# is via a feature called generic type inferencing while in Java this is done using wildcard types. The following code samples show how both approaches lead to the same result.
C# Code
using System;
using System.Collections;
using System.Collections.Generic; 

class Test{

    //Prints the contents of any generic Stack by 
    //using generic type inference 
    public static void PrintStackContents<T>(Stack<T> s){
        while(s.Count != 0){
            Console.WriteLine(s.Pop()); 
        } 
    }

    public static void Main(String[] args){

    Stack<int> s2 = new Stack<int>(); 
    s2.Push(4); 
    s2.Push(5); 
    s2.Push(6); 

    PrintStackContents(s2);     

    Stack<string> s1 = new Stack<string>(); 
    s1.Push("One"); 
    s1.Push("Two"); 
    s1.Push("Three"); 

    PrintStackContents(s1); 
    }
}

Java Code
import java.util.*; 

class Test{

    //Prints the contents of any generic Stack by 
    //specifying wildcard type 
    public static void PrintStackContents(Stack<?> s){
        while(!s.empty()){
            System.out.println(s.pop()); 
        }
    }

    public static void main(String[] args){

    Stack <Integer> s2 = new Stack <Integer>(); 
    s2.push(4); 
    s2.push(5); 
    s2.push(6); 

    PrintStackContents(s2);     

    Stack<String> s1 = new Stack<String>(); 
    s1.push("One"); 
    s1.push("Two"); 
    s1.push("Three");   

    PrintStackContents(s1); 
    }
}


It isn't (quite) true that there is no equivalent in C#. There is no static equivalent that you can use as a type, or call methods on, true enough. For that, use Jorge's answer.
On the other hand, sometimes you need the equivalent idea for reflection, and there is an equivalent there. If you have:
interface IFoo<T>
{
  T Bar(T t, int n);
}

you can get a Type that represents IFoo<int> using typeof(IFoo<int>). Less well known, and a partial answer to your question, is that you can also get a Type that represents IFoo<T> using typeof(IFoo<>).
This is useful when you want to use IFoo<T> for some T through reflection and won't know T until runtime.
Type theInterface = typeof(IFoo<>);
Type theSpecificInterface = theInterface.MakeGenericType(typeof(string));

// theSpecificInterface now holds IFoo<string> even though we may not have known we wanted to use string until runtime

// proceed with reflection as normal, make late bound calls / constructions, emit DynamicMethod code, etc.


While admittedly being not the clean approach, using Foo<object> x may also be suitable.
