How does the Java for each loop work?
java foreach syntactic-sugar
List<String> someList = new ArrayList<String>();
// add "monkey", "donkey", "skeleton key" to someList

for (String item : someList) {
    System.out.println(item);
}

What would the equivalent for loop look like without using the for each syntax?


for(Iterator<String> i = someList.iterator(); i.hasNext(); ) {
    String item = i.next();
    System.out.println(item);
}

Note that if you need to use i.remove(); in your loop, or access the actual iterator in some way, you cannot use the for( : ) idiom, since the actual Iterator is merely inferred.
As was noted by Denis Bueno, this code works for any object that implements the Iterable interface.
Also, if the right-hand side of the for(:) idiom is an array rather than an Iterable object, the internal code uses an int index counter and checks against array.length instead. See the Java Language Specification.

The for-each loop in java uses the underlying iterator mechanism. So it's identical to the following:
Iterator<String> iterator = someList.iterator();

while (iterator.hasNext()) {
  String item = iterator.next();
  System.out.println(item);
}


Here's an equivalent expression.
for(Iterator<String> sit = someList.iterator(); sit.hasNext(); ) {
    System.out.println(sit.next());
}


It would look something like this. Very crufty. 
for (Iterator<String> i = someList.iterator(); i.hasNext(); )
        System.out.println(i.next());

There is a good writeup on for each in the Sun documentation.

for (Iterator<String> itr = someList.iterator(); itr.hasNext(); ) {
   String item = itr.next();
   System.out.println(item);
}


It's implied by nsayer's answer, but it's worth noting that the OPs for(..) syntax will work when "someList" is anything that implements java.lang.Iterable -- it doesn't have to be a list, or some collection from java.util.  Even your own types, therefore, can be used with this syntax.

Also note that using the "foreach" method in the original question does have some limitations, such as not being able to remove items from the list during the iteration.
The new for-loop is easier to read and removes the need for a separate iterator, but is only really usable in read-only iteration passes.

for each is also valid for arrays. e.g.
int[] test = new int[] {1,4,5,7};

for (int intValue : test) {
    // do some work here on intValue
}

which is essentially equivalent of
int[] test = new int[] {1,4,5,7};

for (int i = 0; i < test.length; i++) {
    int intValue = test[i];
    // do some work here on intValue
}

So, overall summary:
[nsayer]The following is the longer form of what is happening:

for(Iterator<String> i = someList.iterator(); i.hasNext(); ) {
  String item = i.next();
  System.out.println(item);
}

Note that if you need to use
  i.remove(); in your loop, or access
  the actual iterator in some way, you
  cannot use the for( : ) idiom, since
  the actual Iterator is merely
  inferred.

[Denis Bueno]

It's implied by nsayer's answer, but
  it's worth noting that the OPs for(..)
  syntax will work when "someList" is
  anything that implements
  java.lang.Iterable -- it doesn't have
  to be a list, or some collection from
  java.util. Even your own types,
  therefore, can be used with this
  syntax.


The Java "for-each" loop construct will allow iteration over two types of objects:

T[] (arrays of any type)
java.lang.Iterable<T>

The Iterable<T> interface has only one method: Iterator<T> iterator().  This works on objects of type Collection<T> because the Collection<T> interface extends Iterable<T>.

Here is an answer which does not assume knowledge of Java Iterators. It is less precise but is useful for education. 
While programming we often write code that looks like the following: 
char[] grades = ....
for(int i = 0; i < grades.length; i++)   // for i goes from 0 to grades.length
    System.out.print(grades[i]);         // print grades[i]

The foreach syntax allows this common pattern to be written in a more natural and less syntactically noisy way.
for(char grade : grades)      // foreach grade in grades
    System.out.print(grade);  // print that grade

Additionally this syntax is valid for objects such as Lists or Sets which do not support array indexing but which do implement the Java Iterable interface. 

The concept of foreach loop as mentioned in wikipedia is highlighted below:

Unlike other for loop constructs, however, foreach loops usually
  maintain no explicit counter: they essentially say "do this to
  everything in this set", rather than "do this x times". This avoids
  potential off-by-one errors and makes code simpler to read.

So the concept of foreach loop describes that the loop does not use any explicit counter which means that there is no need of using indexes to traverse in the list thus it saves user from off-by-one error. To describe the general concept of this off-by-one error. Let us take an example of a loop to traverse in a list using indexes.
// In this loop it is assumed that the list starts with index 0
for(int i=0; i<list.length;i++){

}

But suppose if the list starts with index 1 then this loop is going to throw an exception as it will found no element at index 0 and this error is called off-by-one error. So to avoid this off-by-one error the concept of foreach loop is used. There may be other advantages too but this is what I think is the main concept and advantage of using foreach loop.

A foreach loop syntax is:
for(type obj:array) {...}

EX:
String[] s = {"Java", "Coffe", "Is", "Cool"};
for(String str:s /*s is the array*/) {
    System.out.println(str);
}

Output:
Java
Coffe
Is
Cool

WARNING: You can access array elements with the foreach loop, but can NOT initialize them. Use the original for loop for that.

WARNING: You must match the type of the array with the other object.
for(double b:s) //Invalid-double is not String

If you want to edit elements, use the original for loop like this:
for(int i = 0; i < s.length-1 /*-1 Because of the 0 index*/; i++) {
    if(i==1) //1 because once again I say the 0 index
        s[i]="2 is cool";
    else    
        s[i] = "hello";
}

Now if we dump s to the consle, we get
hello
2 is cool
hello
hello


The foreach loop, added in Java 5 (also called the "enhanced for loop"), is equivalent to using a java.util.Iterator--it's syntactic sugar for the same thing. Therefore, when reading each element, one by one and in order, a foreach should always be chosen over an iterator, as it is more convenient and concise.
foreach
for(int i : intList)  {
   System.out.println("An element in the list: " + i);
}

Iterator
Iterator<Integer> intItr = intList.iterator();
while(intItr.hasNext())  {
   System.out.println("An element in the list: " + intItr.next());
}

There are situations where you must use an Iterator directly. For example, attempting to delete an element while using a foreach can (will?) result in a ConcurrentModificationException.
foreach vs. for: Basic differences
The only practical difference between for and foreach is that, in the case of indexable objects, you do not have access to the index. An example when the basic for loop is required:
for(int i = 0; i < array.length; i++)  {
   if(i < 5)  {
      //Do something special
   }  else  {
      //Do other stuff
   }
}

Although you could manually create a separate index int-variable with foreach
int idx = -1;
for(int i : intArray)  {
   idx++;
   ...
}

it is not recommended, since variable-scope is not ideal, and the basic for loop is simply the standard and expected format for this use-case.
foreach vs. for: Performance
When accessing collections, a foreach is significantly faster than the basic for loop's array access. When accessing arrays, however--at least with primitive and wrapper-arrays--access via indexes is dramatically faster.
Timing the difference between iterator and index access for primitive int-arrays
Indexes are 23-40 percent faster than iterators when accessing int or Integer arrays. Here is the output from the testing class at the bottom of this post, which sums the numbers in a 100-element primitive-int array (A is iterator, B is index):
[C:\java_code\]java TimeIteratorVsIndexIntArray 1000000
Test A: 358,597,622 nanoseconds
Test B: 269,167,681 nanoseconds
B faster by 89,429,941 nanoseconds (24.438799231635727% faster)

[C:\java_code\]java TimeIteratorVsIndexIntArray 1000000
Test A: 377,461,823 nanoseconds
Test B: 278,694,271 nanoseconds
B faster by 98,767,552 nanoseconds (25.666236154695838% faster)

[C:\java_code\]java TimeIteratorVsIndexIntArray 1000000
Test A: 288,953,495 nanoseconds
Test B: 207,050,523 nanoseconds
B faster by 81,902,972 nanoseconds (27.844689860906513% faster)

[C:\java_code\]java TimeIteratorVsIndexIntArray 1000000
Test A: 375,373,765 nanoseconds
Test B: 283,813,875 nanoseconds
B faster by 91,559,890 nanoseconds (23.891659337194227% faster)

[C:\java_code\]java TimeIteratorVsIndexIntArray 1000000
Test A: 375,790,818 nanoseconds
Test B: 220,770,915 nanoseconds
B faster by 155,019,903 nanoseconds (40.75164734599769% faster)

[C:\java_code\]java TimeIteratorVsIndexIntArray 1000000
Test A: 326,373,762 nanoseconds
Test B: 202,555,566 nanoseconds
B faster by 123,818,196 nanoseconds (37.437545972215744% faster)

I also ran this for an Integer array, and indexes are still the clear winner, but only between 18 and 25 percent faster.
For collections, iterators are faster than indexes
For a List of Integers, however, iterators are the clear winner. Just change the int-array in the test-class to
List<Integer> intList = Arrays.asList(new Integer[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100});

and make the necssary changes to the test-function (int[] to List<Integer>, length to size(), etc)
[C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000
Test A: 3,429,929,976 nanoseconds
Test B: 5,262,782,488 nanoseconds
A faster by 1,832,852,512 nanoseconds (34.326681820485675% faster)

[C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000
Test A: 2,907,391,427 nanoseconds
Test B: 3,957,718,459 nanoseconds
A faster by 1,050,327,032 nanoseconds (26.038700083921256% faster)

[C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000
Test A: 2,566,004,688 nanoseconds
Test B: 4,221,746,521 nanoseconds
A faster by 1,655,741,833 nanoseconds (38.71935684115413% faster)

[C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000
Test A: 2,770,945,276 nanoseconds
Test B: 3,829,077,158 nanoseconds
A faster by 1,058,131,882 nanoseconds (27.134122749113843% faster)

[C:\java_code\]java TimeIteratorVsIndexIntegerList 1000000
Test A: 3,467,474,055 nanoseconds
Test B: 5,183,149,104 nanoseconds
A faster by 1,715,675,049 nanoseconds (32.60101667104192% faster)

[C:\java_code\]java TimeIteratorVsIndexIntList 1000000
Test A: 3,439,983,933 nanoseconds
Test B: 3,509,530,312 nanoseconds
A faster by 69,546,379 nanoseconds (1.4816434912159906% faster)

[C:\java_code\]java TimeIteratorVsIndexIntList 1000000
Test A: 3,451,101,466 nanoseconds
Test B: 5,057,979,210 nanoseconds
A faster by 1,606,877,744 nanoseconds (31.269164666060377% faster)

In one test they're almost equivalent, but with collections, iterator wins.
This post is based on two answers I wrote on stackexchange:
Uses and syntax for for-each loop in Java
Should I use an Iterator or a forloop to iterate?

Some more information: Which is more efficient, a for-each loop, or an iterator?
The full testing class
I created this compare-the-time-it-takes-to-do-any-two-things class after reading this question on stackoverflow
   import  java.text.NumberFormat;
   import  java.util.Locale;
/**
   &lt;P&gt;{@code java TimeIteratorVsIndexIntArray 1000000}&lt;/P&gt;

   @see  &lt;CODE&gt;&lt;A HREF=&quot;http://stackoverflow.com/questions/180158/how-do-i-time-a-methods-execution-in-java&quot;&gt;http://stackoverflow.com/questions/180158/how-do-i-time-a-methods-execution-in-java&lt;/A&gt;&lt;/CODE&gt;
 **/
public class TimeIteratorVsIndexIntArray  {
   public static final NumberFormat nf = NumberFormat.getNumberInstance(Locale.US);
   public static final void main(String[] tryCount_inParamIdx0)  {
      int testCount;
      //Get try-count from command-line parameter
         try  {
            testCount = Integer.parseInt(tryCount_inParamIdx0[0]);
         }  catch(ArrayIndexOutOfBoundsException | NumberFormatException x)  {
            throw  new IllegalArgumentException("Missing or invalid command line parameter: The number of testCount for each test. " + x);
         }

      //Test proper...START
         int[] intArray = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100};

         long lStart = System.nanoTime();
            for(int i = 0; i < testCount; i++)  {
               testIterator(intArray);
            }
         long lADuration = outputGetNanoDuration("A", lStart);

         lStart = System.nanoTime();
            for(int i = 0; i < testCount; i++)  {
               testFor(intArray);
            }
         long lBDuration = outputGetNanoDuration("B", lStart);

         outputGetABTestNanoDifference(lADuration, lBDuration, "A", "B");
   }
      private static final void testIterator(int[] int_array)  {
         int total = 0;
         for(int i = 0; i < int_array.length; i++)  {
            total += int_array[i];
         }
      }
      private static final void testFor(int[] int_array)  {
         int total = 0;
         for(int i : int_array)  {
            total += i;
         }
      }
      //Test proper...END

//Timer testing utilities...START
   public static final long outputGetNanoDuration(String s_testName, long l_nanoStart)  {
      long lDuration = System.nanoTime() - l_nanoStart;
      System.out.println("Test " + s_testName + ": " + nf.format(lDuration) + " nanoseconds");
      return  lDuration;
   }

   public static final long outputGetABTestNanoDifference(long l_aDuration, long l_bDuration, String s_aTestName, String s_bTestName)  {
      long lDiff = -1;
      double dPct = -1.0;
      String sFaster = null;
      if(l_aDuration > l_bDuration)  {
         lDiff = l_aDuration - l_bDuration;
         dPct = 100.00 - (l_bDuration * 100.0 / l_aDuration + 0.5);
         sFaster = "B";
      }  else  {
         lDiff = l_bDuration - l_aDuration;
         dPct = 100.00 - (l_aDuration * 100.0 / l_bDuration + 0.5);
         sFaster = "A";
      }
      System.out.println(sFaster + " faster by " + nf.format(lDiff) + " nanoseconds (" + dPct + "% faster)");
      return  lDiff;
   }
//Timer testing utilities...END
}


In Java 8 features you can use that :
List<String> messages = Arrays.asList(new String[] { "First", "Second","Third"});

void forTest(){
    messages.forEach(System.out::println);
}

--Output
First
Second
Third


The Java for-each idiom can only be applied to arrays or objects of type *Iterable. This idiom is implicit as it truly backed by an Iterator. The Iterator is programmed by the programmer and often uses an integer index or a node (depending on the data structure) to keep track of its position. On paper it is slower than a regular for-loop, a least for "linear" structures like arrays and Lists but it provides greater abstraction. 

You can implement Iterable.
Here's an example. It's not the best, as the object is its own iterator. However it should give you an idea as to what's going on.

It adds beauty to your code by removing all the basic looping clutter. It gives a clean look to your code, justified below.
normal for loop:
void cancelAll(Collection<TimerTask> list) {
    for (Iterator<TimerTask> i = list.iterator(); i.hasNext();)
         i.next().cancel();
}

using for-each:
void cancelAll(Collection<TimerTask> list) {
    for (TimerTask t : list)
        t.cancel();
}

for-each is a construct over a collection that implements Iterator. Remember that, your collection should implement Iterator, otherwise you can't use it with for-each.
the following line is read as "for each TimerTask t in list."
for (TimerTask t : list)

There is less chance for errors in case of for-each. You don't have to worry about initializing the iterator or initializing the loop counter and terminating it(where there is scope for errors).

As defined in JLS for-each loop can have two forms:

If the type of Expression is a subtype of Iterable then translation is as:
List<String> someList = new ArrayList<String>();
someList.add("Apple");
someList.add("Ball");
for (String item : someList) {
    System.out.println(item);
}

// IS TRANSLATED TO:

for(Iterator<String> stringIterator = someList.iterator(); stringIterator.hasNext(); ) {
    String item = stringIterator.next();
    System.out.println(item);
}

If the Expression necessarily has an array type T[] then:
String[] someArray = new String[2];
someArray[0] = "Apple";
someArray[1] = "Ball";

for(String item2 : someArray) {
    System.out.println(item2);
}

// IS TRANSLATED TO:
for (int i = 0; i < someArray.length; i++) {
    String item2 = someArray[i];
    System.out.println(item2);
}


Java 8 has introduced streams which perform generally better. We can use them as:
someList.stream().forEach(System.out::println);
Arrays.stream(someArray).forEach(System.out::println);

