Storing more than 1 data item at a single index in a linked-list?
java collections linked-list
I am trying to store more than 1 data item at a single index in my linked-list.  All of the examples in my textbook seem to illustrate adding only 1 piece of data per index.  I'm assuming it is possible to add more?
For example, using the Collections API to store an integer I would do the following:
LinkedList <Integer>linky = new LinkedList<Integer>();
int num1 = 2, num2 = 22, num3 = 25, num4 = 1337;
linky.add(num1);

How would I go about adding num2, num3, and num4 to the same first index in the list?  Thanks guys.  


Use a structure.
For example:
private struct Node
{
    int Num1;
    int Num2;
    int Num3;
}

...
LinkedList<Node> list = new LnkedList<Node>();

Node n = new Node();
n.Num1 = 10;
n.Num2 = 100;
n.Num3 = 1000;
list.Add(n);

Note; I assume this is in C#; correct me if I'm wrong and I will fix the code ;)
If you have not gone over OOP yet in your book - then I would recommend giving it a try; it will help you solve problems like this.

Why not something like that:
LinkedList<LinkedList<Integer>> linky = new LinkedList<LinkedList<Integer>>();
//...
linky.add(new LinkedList<Integer>().add( //...


There seems to be a little confusion about how linked lists work.  Essentially, a linked list is composed of nodes, each of which contains one datum (an object, which itself can contain several member variables, to be precise), and a link to the next node in the list (or a null pointer if there is no such next node).  You can also have a doubly-linked list, where each node also has a pointer to the previous node in the list, to speed up certain kinds of access patterns.
To add multiple "pieces of data" to a single node sounds like adding several links off of one node, which turns your linked list into an N-ary tree.
To add multiple pieces of data onto the end of the list, in the manner most commonly associated with a linked list, just do:
LinkedList <Integer>linky = new LinkedList<Integer>();
int num1 = 2, num2 = 22, num3 = 25, num4 = 1337;
linky.add(num1);
linky.add(num2);
linky.add(num3);
linky.add(num4);

Alternately, if you want each node of the linked list to have several pieces of data
These data should be packaged up into an object (by defining a class that has them all as member variables).  For example:
class GroupOfFourInts
{
   int myInt1;
   int myInt2;
   int myInt3;
   int myInt4;

   public GroupOfFourInts(int a, int b, int c, int d)
   {
     myInt1 = a; myInt2 = b; myInt3 = c; myInt4 = d;
   }
}

class someOtherClass
{

  public static void main(String[] args)
  {
    LinkedList<GroupOfFourInts> linky = new LinkedList<GroupOfFourInts>();
    GroupOfFourInts group1 = new GroupOfFourInts(1,2,3,4);
    GroupOfFourInts group2 = new GroupOfFourInts(1337,7331,2345,6789);
    linky.add(group1);
    linky.add(group2);
  }
}

Now, linky will have 2 nodes, each of which will contain 4 ints, myInt1, myInt2, myInt3, and myInt4.
Note
None of the above is specific to linked lists.  This pattern should be used whenever you want to store a bunch of data together as a unit.  You create a class that has member variables for every piece of data you want to be stored together, then create any Java Collections type (ArrayList, LinkedList, TreeList, ...) of that type.
Be sure that you want to use a linked list (as there's no penalty in terms of programming difficulty in choosing an ArrayList or TreeList).  This will depend on your data access pattern.  Linked lists provide O(1) addition and deletion, but O(n) lookup, whereas ArrayLists provide O(1) lookup, but O(n) arbitrary add and delete.  TreeLists provide O(log n) insertion, deletion, and lookup.  The tradeoffs between these depend on the amount of data you have and how you're going to be modifying and accessing the data structure.
Of course, none of this matters if you'll only have, say, <100 elements in your list ;-)
Hope this helps!

Like Nelson said you need another Object, in Java though you need to use a Class.
If you need the 'Node' Class to be used outside the Class you're working in, then you need to make it a Public class, and move it to it's own file.
private Class Node
{
    //You might want to make these private, and make setters and getters
    public int Num1;
    public int Num2;
    puclic int Num3;
}

LinkedList<Node> list = new LinkedList<Node>();

Node n = new Node();
n.Num1 = 10;
n.Num2 = 100;
n.Num3 = 1000;
list.Add(n);

Apologies to Nelson for stealing his code ;)

Here's a complete code sample that shows the use of adding a structure to a linked list:
import java.util.LinkedList;
class Node {
    int num1;
    int num2;
    int num3;
    int num4;
    public Node(int a, int b, int c, int d) {
        num1 = a; num2 = b; num3 = c; num4 = d;
    }
}
public class dummy {
    public static void main(String[] args) {
        LinkedList <Node>linky = new LinkedList<Node>();
        x myNode = new Node(2, 22, 25, 1337);
        linky.add(myNode);
    }
}


I don't really understand what you are trying to achieve, so I suggest a solution to another reading of the problem (in java).
LinkedList <Integer>linky = new LinkedList<Integer>();
linky.add(num1);

// Lots of code possibly adding elements somewhere else in the list

if (linky.size() > 0) { // Always good to be sure; especially if this is in another methode
 int first = linky.get(0);
 linky.set(0, first + num2);// Value of linky.get(0) is num1 + num2 
}


// The same again
// Lots of code possibly adding elements somewhere else in the list

if (linky.size() > 0) { // Always good to be sure; especially if this is in another methode
 int first = linky.get(0);
 linky.set(0, first + num3); // Value of linky.get(0) is num1 + num2 + num3
}

I personally happen to like Nelson's solution best if the amount of numbers to add is constant (num1 .. num4),
and if it is not constant I would prefer Gregor's solution (who uses a List in stead of a Node). If you go for the Node method in java I suggest:
// added static, Class to class
private static class Node
{
    //You might want to make these private, and make setters and getters
    public int Num1;
    public int Num2;
    puclic int Num3;
}

// Prefer interfaces if possible
List<Node> list = new LinkedList<Node>();

Node n = new Node();
n.Num1 = 10;
n.Num2 = 100;
n.Num3 = 1000;
list.add(n); // Add -> add

Lot's of nitpicking, but I think a static class in stead of a none-static private class is preferred if possible (and it normally should be possible).
