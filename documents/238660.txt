Difference of two 'uint'
c# .net
When you attempt to declare an unsigned variable in C#.NET with a value outside its value range it is flagged as a compiler error, but if you produce a negative value at runtime and assign it to that variable at runtime the value wraps.
uint z = -1; // Will not compile

uint a = 5;
uint b = 6;
uint c = a - b; // Will result in uint.MaxValue

Is there a good reason why unsigned variables wrap in such a situation instead of throwing an exception?
Thanks.


Declaring an unassigned variable in C# isn't flagged with an error - trying to assign an invalid value to a variable is. For instance, here's a variable which isn't definitely assigned (assuming it's local) after declaration:
uint z;

-1 isn't a valid value for a uint any more than 0.5 is, which is why your example wouldn't compile.
Now, as for the rest: integers types just wrap on overflow - just as adding 1 to int.MaxValue returns int.MinValue. This is a significant performance improvement over having the program check each operation for overflow - at the cost of potentially not spotting an error.
That's only if you're in an unchecked context, mind you - if you perform any of these operations in a checked context, you'll get an exception instead. For instance;
class Test
{
    static void Main()
    {
        checked
        {
            uint a = 5;
            uint b = 6;
            uint c = a - b;
        }
    }
}

Run that and you'll see an OverflowException get thrown. If that's what you want for your whole project, you can set it in the project properties (or compile with the /checked+ command line option to csc.)
EDIT: It's worth noting that the other answers have shown that you could put smaller amounts of code in the checked context - just the declaration and assignment of c or even just the calculation. It's all pretty flexible.

The wrapping is because by dfault C# is unchecked. If you add a "checked" block, the overflow will be detected:
    uint a = 3, b = 4;
    checked
    {
       uint c = a - b; // throws an overflow
    }

As for the compiler: it simply demands valid data.

This is just the default - you can change the compilation settings to enable runtime arithetic overflow checks. If you turn that on, exceptions will be thrown as you are expecting. Alternatively, you can turn on checking for a specific operation by placing it inside a checked block.
uint c = checked(a - b);


Probably worth clarifying here that uint is an unsigned int, not an unassigned int. Big difference!

The reason it wraps to negative is because of Two's Complement math that is used for integer arithmetic.  
The short answer is that the most significant bit is used as the sign.  A zero is positive; a one is negative.

Always use double. The performance difference is insignificant, and it is more flexible and accommodating. This practice prevents exceptions and reduces development time. Anal people hate it though.  
