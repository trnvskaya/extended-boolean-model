In .NET CF 2.0, will a global keyboard hook interfere with P/Invokes that require a keypress?
.net winapi compact-framework pinvoke windows-ce
My details: custom mobile device running Windows CE 4.2, Compact Framework 2.0 SP1. C# app making decent use of P/Invokes with no problems until now.
I've written a low-level keyboard hook (similar to, but not identical to, this CodeProject post) which works marvelously with one exception. One thing that our software does is allow access to Windows CE's screen-calibration functionality; this is the screen upon which you need to tap a series of targets, finally pressing Esc to cancel or Enter to accept. We call this functionality via a P/Invoke, and I think the keypress that occurs inside this Win32 API function is being interfered with by my keyboard hook. 
My keyboard hook doesn't do anything intensive, and doesn't change execution flow, but I think the use of the two may be fundamentally incompatible. When I exit the debugger after running this screen, all the Enter key presses I've attempted all "hit" at once (this device makes a clicky typing noise) when the program closes. This makes me think that the hook is not properly passing the keypress into the Win32 API function the way it correctly does to a .NET application. Any thoughts?
Do you think that:
a) Keyboard hooks and keyboard-requiring P/Invokes are incompatible, or
b) my implementation of the keyboard hook is to blame, or
c) does it depend at all on the hardware manufacturer, drivers, etc?
Thanks for your help!


a) No, they are fully compatible.  The keyboard hook happens down at the kenel level, so anything that uses a keyboard message will go through it, whether it's coming from native or managed code.
b) Hard to say since we can't see your implementation
c) This is possible (anything is since just about everything in CE is OEM changeable) but not terribly likely.  Most OEMs don't much with GWES (which is where this lies) because it works out of the box.
Now the specific piece you're looking at I assume is from a call to TouchCalibrate, correct?  The best bet here is to look specifically at the TouchCalibrate source code - it comes with Platform Builder (including the eval version).  
My guess is that it's "intercepting" or at least preventing the messages from getting dispatched. It's been a while since I was in there, and that was while doing a touchpanel driver so I didn't look much at the keyboard handling, but what it's doing it passign control down to the GWES subsystem to look at the raw touchpanel points - it's not running a Windows app.  So it's likely that the app message pump, which would handle dispatching those keypresses, is doing nothing (kind of like when you toss up a modal dialog).
I'd really need a better explanation of exactly what's happening.  You say "when you exit the debugger after running this screen" but I'm not clear what that means.  You mean you call TouchCalibrate in code, then stop debugging and then the messages get dispatched, or do they get dispatched once the TouchCalibrate itself screen closes?
Remote Spy++ or Kernel Tracker might also give some insight into what's happening.
