Pass NSMutableArray object
objective-c
I'm getting lost in pointer land, I believe.  I've got this (code syntax might be a little off, I am not looking at the machine with this code on it...but all the pertinent details are correct):
NSMutableArray *tmp = [[NSMutableArray alloc] init];

I them pass that to a routine in another class
- (BOOL)myRoutine: (NSMutableArray *)inArray
{
    // Adds items to the array -- if I break at the end of this function, the inArray variable has a count of 10
}

But when the code comes back into the calling routine, [tmp count] is 0.
I must be missing something very simple and yet very fundamental, but for the life of me I can't see it.  Can anyone point out what I'm doing wrong?
EDIT: www.stray-bits.com asked if I have retained a reference to it, and I said "maybe...we tried this:  NSMutableArray *tmp = [[[NSMutableArray alloc] init] retain]; not sure if that is what you mean, or if I did it right.
EDIT2:  Mike McMaster and Andy -- you guys are probably right, then.  I don't have the code here (it's on a colleague's machine and they have left for the day), but to fill the array with values we were doing something along the lines of using a decoder(?) object.  
The purpose of this function is to open a file from the iPhone, read that file into an array (it's an array of objects that we saved in a previous run of the program).  That "decoder" thing has a method that puts data into the array.  
Man, I've totally butchered this.  I really hope you all can follow, and thanks for the advice.  We'll look more closely at it.


NSMutableArray retains objects added to it, but have you retained the array itself?

You don't need to call retain in this case. [[NSMutableArray alloc] init] creates the object with a retain count of 1, so it won't get released until you specifically release it.
It would be good to see more of the code. I don't think the error is in the very small amount you've posted so far..

I agree with Mike - based on the code you've posted, it looks correct. In addition to posting the code used to call the function and add items to the array, you could try checking the memory addresses of the pointer at the end of the function (when it has all of the objects), and also once it has returned (when it has no objects). I'm not sure why it would be different, but then again the items should stick in the array as well.

You need to show us a bit more of how you're adding objects to the array for us to really help.
I've seen a lot of people write code like this:
NSMutableArray *array = [[NSMutableArray alloc] initWithCapacity:0];

array = [foo bar];

People doing this think it "creates and then sets" a mutable array, but that's not at all what it does.  Instead, it creates a mutable array, assigns it to the variable named array, and then assigns a different mutable array to that variable.
So be sure you're not confusing the variable for the object to which it is a reference.  The object isn't the variable, it's interacted with through the variable.

The code you posted should work. You must be doing something funny in the decoder function.
You should not retain that array. It's automatically retained with init. If you retain it, you'll leak memory. If you are just starting with objective c, take time and read "Introduction to Memory Management Programming Guide for Cocoa". It will spare you lots of headache.
Why are you writing so much code to read an array from a file? It's already supported by the framework:

+ arrayWithContentsOfFile:
Returns an array initialized from the contents of a specified file.
  The specified file can be a full or
  relative pathname; the file that it
  names must contain a string
  representation of an array, such as
  that produced by the
  writeToFile:atomically: method.

So you can do this:
NSMuatableArray *myArray = [NSMutableArray arrayWithContentsOfFile:@"path/to/my/file"];

This is a convenience method, so the object will autorelease. Make sure to retain this one if you want to keep it around.
