Should javac find methods outside of an anonymous class of the same name?
java methods javac anonymous-class
This question is a follow up to:
Why canât I call a method outside of an anonymous class of the same name
This previous question answer why, but now I want to know if javac should find run(int bar)?  (See previous question to see why run(42) fails)
If it shouldn't, is it due to a spec?  Does it produce ambiguous code?  My point is, I think this is a bug.  While the previous question explained why this code fails to compile, I feel it should compile if javac searched higher in the tree if it fails to find a match at the current level.  IE.  If this.run() does not match, it should automatically check NotApplicable.this for a run method.
Also note that foo(int bar) is correctly found.  If you give any reason why run(int bar) shouldn't be found, it must also explain why foo(int bar) is found.
public class NotApplicable {

    public NotApplicable() {
        new Runnable() {
            public void run() {

                // this works just fine, it automatically used NotApplicable.this when it couldn't find this.foo
                foo(42);

                // this fails to compile, javac find this.run(), and it does not match
                run(42);

                // to force javac to find run(int bar) you must use the following
                //NotApplicable.this.run(42);
            }
        };
    }

    private void run(int bar) {
    }

    public void foo(int bar) {
    }
}



Sounds like a recipe for ambiguity and fragility to me - as soon as a new method is added in your base class (okay, not so likely for an interface...) the meaning of your code changes completely.
Anonymous classes are pretty ugly already - making this bit of explicit doesn't bother me at all. 

This behavior of javac conforms to the spec. See Â§15.12 Method Invocation Expressions in the Java Language Specification, specifically the paragraph under "Compile Time Step 1" explaining the meaning of an unqualified method invocation:

If the Identifier appears within the scope (Â§6.3) of a visible method declaration with that name, then there must be an enclosing type declaration of which that method is a member. Let T be the innermost such type declaration. The class or interface to search is T. 

In other words, the unqualified method name is searched for in all enclosing scopes, and the innermost "type declaration" (which means either a class or an interface declaration) in which the name is found is the one that will be searched for the whole signature (in "Compile Time Step 2").

Try
NotApplicable.this.run(42);

instead.
