listing all functions in a python module
python
I have a python module installed on my system and I'd like to be able to see what functions/classes/methods are available in it.   
I want to call the doc function on each one. In ruby I can do something like ClassName.methods to get a list of all the methods available on that class. Is there something similar in python?
eg. something like:
from somemodule import foo
print foo.methods # or whatever is the correct method to call



You can use dir(module) to see all available methods/attributes.  Also check out PyDocs.

The inspect module. Also see the pydoc module, the help() function in the interactive interpreter and the pydoc command-line tool which generates the documentation you are after. You can just give them the class you wish to see the documentation of. They can also generate, for instance, HTML output and write it to disk.

import types
import yourmodule

print [yourmodule.__dict__.get(a) for a in dir(yourmodule)
  if isinstance(yourmodule.__dict__.get(a), types.FunctionType)]


Once you've imported the module, you can just do:
 help(modulename)

... To get the docs on all the functions at once, interactively.  Or you can use:
 dir(modulename)

... To simply list the names of all the functions and variables defined in the module.

This will do the trick:
dir(module) 

However, if you find it annoying to read the returned list, just use the following loop to get one name per line.
for i in dir(module): print i


An example with inspect:
from inspect import getmembers, isfunction
from my_project import my_module

functions_list = [o for o in getmembers(my_module) if isfunction(o[1])]

getmembers returns a list of (object_name, object_type) tuples.
You can replace isfunction with any of the other isXXX functions in the inspect module.

dir(module) is the standard way when using a script or the standard interpreter, as mentioned in most answers.
However with an interactive python shell like IPython you can use tab-completion to get an overview of all objects defined in the module. 
This is much more convenient, than using a script and print to see what is defined in the module.

module.<tab> will show you all objects defined in the module (functions, classes and so on)
module.ClassX.<tab> will show you the methods and attributes of a class
module.function_xy? or module.ClassX.method_xy? will show you the docstring of that function / method
module.function_x?? or module.SomeClass.method_xy?? will show you the source code of the function / method. 


It is not (or at least no longer) proper to use dir(module). The  code should read like this:
dir('module') or dir('modules') 

Or you specify the module you want like this: dir('sys') to produce results from the module name sys. dir() returns errors while dir('') is what you need. *help('') will return help information if available for most functions. eg; help('modules') will return module help info.
Thanks for all the down votes. I was using Python3.2.2 and other 3x versions when I posted this. The point was to use (' stuff ') instead of the previous ( stuff ). But I'm assuming your all stuck on Python2 or using newer versions for PC not mobile like I was. 
http://effbot.org/librarybook/sys.htm

None of these answers will work if you are unable to import said Python file without import errors. This was the case for me when I was inspecting a file which comes from a large code base with a lot of dependencies. The following will process the file as text and search for all method names that start with "def" and print them and their line numbers.
import re
pattern = re.compile("def (.*)\(")
for i, line in enumerate(open('Example.py')):
  for match in re.finditer(pattern, line):
    print '%s: %s' % (i+1, match.groups()[0])


For completeness' sake, I'd like to point out that sometimes you may want to parse code instead of importing it. An import will execute top-level expressions, and that could be a problem.
For example, I'm letting users select entry point functions for packages being made with zipapp. Using import and inspect risks running astray code, leading to crashes, help messages being printed out, GUI dialogs popping up and so on.
Instead I use the ast module to list all the top-level functions:
import ast
import sys

def top_level_functions(body):
    return (f for f in body if isinstance(f, ast.FunctionDef))

def parse_ast(filename):
    with open(filename, "rt") as file:
        return ast.parse(file.read(), filename=filename)

if __name__ == "__main__":
    for filename in sys.argv[1:]:
        print(filename)
        tree = parse_ast(filename)
        for func in top_level_functions(tree.body):
            print("  %s" % func.name)

Putting this code in list.py and using itself as input, I get:
$ python list.py list.py
list.py
  top_level_functions
  parse_ast

Of course, navigating an AST can be tricky sometimes, even for a relatively simple language like Python, because the AST is quite low-level. But if you have a simple and clear use case, it's both doable and safe.
(Though, a downside is that you can't detect functions that are dynamically generated, like foo = lambda x,y: x*y.)

In IPython you can use tab autocompletion to list available functions in a module.
Specifically, type foo. then hit the tab key.

You can use the following method to get list all the functions in your module from shell:
import module
module.*?

