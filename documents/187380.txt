Why use Ruby instead of Smalltalk?
ruby-on-rails ruby smalltalk seaside
Ruby is becoming popular, largely from the influence Ruby on Rails, but it feels like it is currently struggling through its adolescence. There are a lot of similarities between Ruby and Smalltalk -- maglev is a testament to that. Despite having a more unusual syntax, Smalltalk has all (if not more) of the object-oriented beauty of Ruby. 
From what I have read, Smalltalk seems to have Ruby beat on:

Maturity (developed in the 1970's)
Stability
Commercial support
Distributed source control (understands structure of code, not just text diffing)
Several implementations of the VM
Cross-platform support
The seaside web framework as a strong alternative to Rails 

It seems like Ruby is just reinventing the wheel. So, why don't Ruby developers use SmallTalk? What does Ruby have the Smalltalk doesn't? 
For the record: I'm a Ruby guy with little to no experience in Smalltalk, but I'm starting to wonder why.

Edit: I think the ease-of-scripting issue has been addressed by GNU Smalltalk. As I understand it, this allows you to write smalltalk in regular old text files, and you no longer need to be in the Smalltalk IDE. You can then run your scripts with:
gst smalltalk_file



Ruby is the current buzz language.  It's easier to market software built with it right now than a language developed in the 70s.

For me its not so much a case of what Ruby has, but what Ruby hasn't. And the thing that it doesn't have is the need for a VM and complete environment.
Smalltalk is great - its where I learnt OO concepts, but for ease of use I go for Ruby. I can write Ruby code in my favourite editor and run it form the command line.
So, for me, thats what I choose Ruby over Smalltalk.

I've done a little Smalltalk - the IDE is one thing I remember - does Ruby have good IDE support?

I think part of the problem is the development-environment-is-the-runtime.  This gives a lot of power, but it also presents a larger learning curve. 
Here is a hello world tutorial.
This is very different from other languages where I just need to know how to open a text editor and copy and paste text, hit save, and run a compiler.  I HAVE to know how to use the environment.  That tutorial doesn't even show me how to create a basic program (which is likely more a fault of that tutorial) that I can run.
There is definately a higher cost of just getting things going than most other languages.
Most languages have some nice eye-catching code that they can show off.  I haven't seen that with Smalltalk.  I also think that there is some stigma to Smalltalk because it has been around so long and it is still relatively obscure.

Community! Ruby and especially Rails has such a great community. When messing around with smalltalk it seemed that there were not as many screen casts, articles, blog posts, etc. written about Smalltalk.

Stephane Ducasse has some great Smalltalk books available here:
http://stephane.ducasse.free.fr/FreeBooks.html
so although the Smalltalk community is not as prolific as the Ruby and Rails communities, there is still some great help out there.

I'm more of a Pythonista than a Ruby user, however the same things hold for Ruby for much the same reasons.

The architecture of Smalltalk is somewhat insular whereas Python and Ruby were built from the ground up to facilitate integration.  Smalltalk never really gained a body of hybrid application support in the way that Python and Ruby have, so the concept of 'smalltalk as embedded scripting language' never caught on.As an aside, Java was not the easiest thing to interface with other code bases (JNI is fairly clumsy), but that did not stop it from gaining mindshare.  IMO the interfacing argument is significant - ease of embedding hasn't hurt Python - but this argument only holds moderate weight as not all applications require this capability.  Also, later versions of Smalltalk did substantially address the insularity.
The class library of most of the main smalltalk implementations (VisualWorks, VisualAge etc.) was large and had reputation for a fairly steep learning curve.  Most key functionality in Smalltalk is hidden away somewhere in the class library, even basic stuff like streams and collections.  The language paradigm is also something of a culture shock for someone not familiar with it, and the piecemeal view of the program presented by the browser is quite different to what most people were used to.The overall effect is that Smalltalk got a (somewhat deserved) reputation for being difficult to learn; it takes quite a bit of time and effort to become a really proficient Smalltalk programmer.  Ruby and Python are much easier to learn and to bring new programmers up to speed with.
Historically, mainstream Smalltalk implementations were quite expensive and needed exotic hardware to run, as can be seen this net.lang.st80 posting from 1983.  Windows 3.1, NT and '95 and OS/2 were the first mass market operating systems on mainstream hardware capable of supporting a Smalltalk implementation with decent native system integration.  Previously, Mac or workstation hardware were the cheapest platforms capable of running Smalltalk effectively.  Some implementations (particularly Digitalk) supported PC operating systems quite well and did succeed in gaining some traction.However, OS/2 was never that successful and Windows did not achieve mainstream acceptance until the mid 1990s.  Unfortunately this coincided with the rise of the Web as a platform and a large marketing push behind Java.  Java grabbed most of the mindshare in the latter part of the 1990s, rendering Smalltalk a bit of an also-ran.
Ruby and Python work in a more conventional toolchain and are not tightly coupled to a specific development environment.  While the Smalltalk IDEs I have used are nice enough I use PythonWin for Python development largely because it has a nice editor with syntax highlighting and doesn't get underfoot.However, Smalltalk is was designed to be used with an IDE (in fact, Smalltalk was the original graphical IDE) and still has some nice features not replicated by other systems.  Testing code with highlight and 'Show it' is still a very nice feature that I have never seen in a Python IDE, although I can't speak for Ruby.
Smalltalk was somewhat late coming to the web application party.  Early efforts such as VisualWave were never terribly successful and it was not until Seaside came out that a decent web framework got acceptance in Smalltalk circles.  In the meantime Java EE has had a complete acceptance lifecycle  starting with raving fanboys promoting it and finally getting bored and moving onto Ruby ;-}Ironically, Seaside is starting to get a bit of mindshare among the cognoscenti so we may find that Smalltalk rides that cycle back into popularity.

Having said that, Smalltalk is a very nice system once you've worked out how to drive it.  


It's true the languages are very much alike. The shallow way to interpret that is to call Ruby a Smalltalk cover band. The more reasonable interpretation is that Smalltalk's closed system isolated it, while Ruby's participation in the Unix ecology and habit of appropriating features from every language under the sun gives it an infinitely gentler adoption curve and effortless integration with kickass tools like Git.

Giles Bowkett

I think the BIGGEST difference is that Ruby is much more similar to perl in terms of USEAGE. Smalltalk never got a foothold into the "scripting" languages.
The VM is really cool and I hope ruby will have something similar to it so we can treat everything on our OS that is written in ruby as object in memory space, however until then I simply enjoy Ruby's terse, short syntax, the ability to just write a tiny script and reuse it later. Ruby got all the advantages of perl and the OOP is much more similar to smalltalk than perl's OOP hack.

You answered the question in your first line: "Ruby is becoming popular"

There are a lot of interesting modules, projects and such based around Ruby. 
If you have trouble doing something in Ruby, it will be trivial to find help somewhere.
Ruby is installed on a lot of computers now (It's included by default on OS X, many Linux distros, and there are good installers for Windows) - I've not seen smalltalk installed by default on any machine I've used..

I would say wether or not one language is superior to another is irrelevant.. As an example, PHP may not be the "best" language ever, but I would still consider using it over Ruby on Rails (a "better" tool for creating websites) because it is so widespread.
Basically, specific pros and cons of a language are far less important than everything surrounding it - namely the community.

I think your question is somewhat missing the point.
You shouldn't choose, you should learn them both!
If you truly are in a position that you can choose the next framework(vm, infrastructure) then you need to decided what to use and can ask a specific question with pros and cons from the perspective of what your application is inteded to do.
I have used smalltalk (love it) and ruby (love it).
At home or for open source project I can use every language I like, but when doing work I have to adopt.
I started to use ruby (at work) because we needed some scripting language that behaved more-or-less equally under solaris,linux and windows(98,2000,xp). Ruby was at that time unknown  to average-joe and there didn't exist any rails. But it was easy to sell to everyone involved. 
(Why not python? the truth ? I once spend a week hunting for a bug that happened when a terminal converted my space to a tab and the intending got messed up).
So people started to code more and more in ruby because it was so relaxing, enjoying and not a cloud on the sky.
Paul Graham sums it up

It's true, certainly, that most people don't choose programming languages simply based on their merits. Most programmers are told what language to use by someone else. 

and 

To be attractive to hackers, a
  language must be good for writing the
  kinds of programs they want to write.
  And that means, perhaps surprisingly,
  that it has to be good for writing
  throwaway programs.

And when were at the Lisp land try to replace LISP with smalltalk


Rubyâs libraries, community, and momentum are good

So if LISP is still more powerful than
  Ruby, why not use LISP? The typical
  objections to programming in LISP are:

There arenât enough libraries.
We canât hire LISP programmers.
LISP has gone nowhere in the past 20 years.

These arenât overwhelming objections,
  but theyâre certainly worth
  considering.

and

Now, given a choice between a powerful
  language, and popular language, it may
  make excellent sense to pick the
  powerful one. But if the difference in
  power is minor, being popular has all
  sorts of nice advantages. In 2005, Iâd
  think long and hard before choosing
  LISP over Ruby. Iâd probably only do
  it if I needed optimized code, or
  macros which acted as full-fledged
  compilers.


what does Ruby have that Smalltalk doesn't?

Massive, current support by major platforms (IronRuby and jRuby) that enrich the set of libraries
Evangelists like Dave Thomas who, for years, have been touring around the country preaching the gospel of their language. I have seen Dave at Java conferences stating he doesn't know Java and that he prefers Ruby.
Strong, current real estate on the bookshelves
The creator of Ruby has said that he thinks about the programmer: Ruby's syntax seems to have this Zen appeal. It is hard to pin down, yet seems to galvanize the fans.
Creative, dynamic presentations like Giles and this one that gain mindshare

I think your point is well-taken.  As a friend once put it, Ruby might be "old wine in a new bottle" vis-a-vis Smalltalk. But sometimes the new bottle matters.  A wine has to be in the right place at the right time.

When I leave my house in the morning to go to work, I often struggle with the decision to make a left or right turn out of my drive way (I live in the middle of a street).  Either way will get me to my destination.  One way leads me to the highway which, depending on traffic, will probably get me to the office the quickest.  I get to drive very fast for at least part of the way and I have a good chance of seeing a pretty girl or two on their way to work :-)
The other way allows me to travel down a very enchanting, windy back road with complete tree cover.  That path is quite enjoyable and of the two approaches is definitely the more fun, though it means that I will get to the office later than I would have had I taken the highway.  Each way has its merits.  On days that I am in a big hurry, I will usually take the highway though I may run into traffic and I also increase my chances of getting into an accident (if I am not careful in my haste).  Other days I may choose the woody path and be driving along, enjoying the scenery and realize that I am running late.  I may try to speed up, raising my chances of getting a ticket or causing an accident myself.
Neither way is better than the other.  They each have their benefits and risks, and each will get me to my goal.

I think everyone who has been working with Ruby for a while recognizes its deep debt to Smalltalk.  As one of these people, what do I like about Ruby over Smalltalk?  I think from a strictly language perspective, it's the sugar.  Ruby is deliberately a very syntax-sugary language, whereas Smalltalk is a very syntax-minimal language.  Ruby is essentially the Smalltalk object model with Perlish syntax sugar.  I happen to like the sugar and find it makes programming more fun.

Because Smalltalk distributions were priced in multiples of $1000USD whereas Ruby is free.

Use Ruby because it has might have business legs, Smalltalk doesn't.
I can tell you from personal experience. Still using Smalltalk, love it, and have used a couple flavors. Although Smalltalk is a great language, and is everything you mentioned,  you wont likely convince the average CIO/CTO to use Smalltalk on a new project.  Of course, you might even have a hard time convincing a conservative CIO/CTO to use Ruby.  In the end you have to be very careful if you want sustained long term commercial support and the ability to find off-the-street employees that can support your systems in the future.  As an example, Smalltalk was a really big thing in the early 90's and IBM invested heavily into it in the late 90's. For IBM Smalltalk was going to be the next language for all business applications. IBM put Smalltalk on everything including their mainframe systems.  Java became popular, took over the market, and Smalltalk became a niche player.  Over a year ago IBM dumped the language (their term is sunset). Also, take a look at the History.  ParkPlace and Digitalk where the first major commercial players in the Smalltalk arena, they merged and then went out of business.

Smalltalk:
people forwards ifTrue: [think] ifFalse: [not thinking]
Ruby:
people think forwards unless thinking backwards
1) Smalltalk's RPN-like control flow by messages is like Lisp - it's regular and cool but weirds people out.
2) Ruby lets people write code using the idiomatic way people speak - do blah unless there's a reason not to.
update rewrote the Smalltalk sample to actually be more legal code..

Ruby is to Smalltalk as Arabic numerals are to Roman numerals. Same math, easier syntax.

I would say the opposite: Smalltalk syntax is one of the simplest and powerful programming language syntaxes.

Guess who said this? (quote is close, maybe not exact): "I always thought Smalltalk would beat Java. I just didn't know if would be called 'Ruby' when it did so."
Drum roll ....
...
The answer is ... Kent Beck

I would go further than Jonke's answer, and say there are now a large number of languages that have a very strong community, almost enough to suit every taste, and a subset of these have mainstream recognition (i.e. your manager will let you use them at work as well).
It's easy to learn the basics of a language, but to actually use it effectively you need to invest enough time to learn the platform and the tools, as well as the syntax and the idioms. IIRC, McConnell claims that it takes about three years to become truly proficient.
Given those things, it's hard to justify spending a lot of time on languages like LISP and Smalltalk, although they are interesting and perhaps educational to look at.

Interesting perspective from Robert Martin (from RailsConf 2009): "What Killed Smalltalk Could Kill Ruby, Too"

I love both Smalltalk and Ruby - but have found that Ruby is more applicable to what I do daily, and is closer to my heart (practically speaking).  What does Ruby offer that Smalltalk doesn't?

Text-based scripting
Low implementation requirements (runs in more places)
Easier to learn and justify (Perl and Python programmers will have no trouble
Easier to move programs around - text files!
Interfaces well with native environment
Anywhere Java runs, jRuby runs...
Bigger and much more active community

Some have mentioned gst (GNU Smalltalk); the problems still hold.

Beats me.  I spent a year checking out Ruby and doing some smallish projects to see how I liked it.  I guess I'm a Smalltalk bigot because every time I'd sit down to work with Ruby I'd sigh and think "I'd really rather be doing this in Smalltalk".  Finally I gave in and went back to Smalltalk.  Now I'm happier.  Happier is gooder.
Which of course begs the question, "Why?".  In no particular order:

Because the IDE blows away anything else I've ever worked with.  This includes a bunch of platforms from ISPF on IBM mainframes to Microsoft's Visual (.*), include things such as Visual Basic 4-6, Visual C++ (various incarnations), Borland's Turbo Pascal and descendants (e.g. Delphi), and stuff on DEC machines in both character mode and under X-Windows.
Because the image is a beautiful place to live.  I can find what I want in there.  If I can't figure out how to do something I know that somewhere in the image is an example of what I'm trying to do - all I have to do is hunt until I find it.  And it's self-documenting - if you want to see the details of how something works you just open a browser on the class you're interested in, look at the method, and that's how it works.  (OK, eventually you'll hit something that calls a primitive, and then it's "here there be dragons", but it's usually understandable from context).  It's possible to do similar things in Ruby/C++/C, but it's not as easy.  Easy is better.
The language is minimal and consistent.  Three kinds of messages - unary, binary, and keyword.  That describes the priority of execution, too - unary messages first, then binary messages, then keyword messages.  Use parentheses to help things out.  Dang little syntax, really - it's all done with message sends.  (OK, assignment isn't a message send, it's an operator.  So's the 'return' operator (^).  Blocks are enclosed by square brace pairs ([ ] ).  Might be one or two other 'magic' bits in there, but darn little...).
Blocks.  Yeah, I know, they're there in Ruby (and others), but dang it, you literally can't program in Smalltalk without using them.  You're forced to learn how to use them.  Sometimes being forced is good.
Object-oriented programming without compromise - or alternatives, for that matter.  You can't pretend that you're "doing objects" while still doing the same old thing.
Because it will stretch your brain.  The comfortable constructs we've all gotten used to (if-then-else, do-while, for( ; ; ), etc) are no longer there so you have to Learn Something New.  There are equivalents to all the above (and more), but you're going to have to learn to think differently.  Differently is good.

On the other hand this may just be the ramblings of a guy who's been programming since the days when mainframes ruled the earth, we had to walk five miles to work through blinding snowstorms, uphill both ways, and computers used donuts for memory.  I've got nothing against Ruby/Java/C/C++/, they're all useful in context, but give me Smalltalk or give me...well, maybe I should learn Lisp or Scheme or... :-)

You can find a job pretty easily doing Ruby. Although I really love Smalltalk, it's virtually impossible to get into the Smalltalk niche. There is work around in it, but if you didn't get in when it was popular it's virtually impossible now.
All the other reasons pale into insignificance because you need to spend plenty of time, focused on real work to learn a language properly. If you're not independently wealthy, the best way to do that is exposure to it at work.

As a latecomer to discussion, the main problem with Smalltalk and Lisp is that you can't run them with CGI or FastCGI on shared hosting.
The unwashed masses are never going to use them if they need VPS or dedicated servers to use them. IMHO Seaside is superior to almost anything out ther, but will it run on Dreamhost or Webfaction?

Use whatever makes you more powerful and faster to beat your challenge.
For us, a little in house framework, we built in top of seaside is really our superpower.
I love the RoR community, it has the right attitude. That's very very valuable. But at the same time, technologically, seaside makes you stronger against more complicated problems.
You can do great seaside web apps using open-source stuff.
dabbledb was a sartup based on seaside and, hey! Avi sold it to twitter in june this year!
I say you don't need to wait for others to approve your initiative.
Just go for it. Make it done. Show us that works.
You're not alone. We are on the same boat.

Ruby (or any other language) is more popular than Smalltalk (or any other language) because we live in a chaotic universe.  To wit:

From Dave Thomas himself, "[after
the] video on 'How to Build a Blog in
Ten Minutes'... Ruby went from being
a nice little niche language, to
being 'a language you wrote Rails
apps in'" (Ruby Conference 2010
keynote).
Early Smalltalk vendors charged prohibitively
Smalltalk, because it was invented (ahead of its time) 30 years ago, occurs to many as an old, "dead" language (like FORTRAN)
corporations consider Smalltalk such a competitive advantage that they hide its use

While the languages are similar in OO features, Smalltalk's killer advantage is the live, open environment (the much-misunderstood 'image').  After you check out this example of programming in Smalltalk, the debate is over.
