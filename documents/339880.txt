Disadvantages of using void* pointers in C
c void-pointers
There are many drawbacks to using void * in C (memory related, type related, efficiency wise ...). In spite of them we use them a lot for the flexibility they provide.
List the disadvantages/drawbacks using void * (and preferred solution in C - if possible).
EDIT:
please go through the follwoing link:
http://attractivechaos.wordpress.com/2008/10/02/using-void-in-generic-c-programming-may-be-inefficient/


Uh ... I'm not sure there are that many. Of course, you should never use void* when you don't have to. If there is a well-defined type you can use, then do that.
In my experience, void* is best for "anonymous" pointers (what a shock!), as in malloc()'s return value, and when just dealing with opaque buffers of bits. Oftentimes, you want to address those buffers at e.g. the byte level, and then you'd use unsigned char *, of course.
Just randomly using void* wherever you need a pointer would be just broken, smelly code, and to be avoided of course.

There are no efficiency issues with void pointers.
The only limitations with void pointers are:

you cannot dereference void pointer for obvious reasons
sizeof(void) is illegal
you cannot perform pointer arithmetics on void pointers

However GCC assumes that sizeof(void) is 1 and allows pointer arithmetics on void pointers - see here

I disagree with the premise of the question.  We use void* in C because it's the only way to get polymorphism.  Example: library functions qsort and bsearch.  There is only one drawback, which is that polymorphism based on void * is unsafe: once you cast a pointer to void *, there is nothing that prevents you from casting that void * to the wrong pointer type by mistake.  My students make this mistake often.
There can be an efficiency cost because it is sometimes necessary to allocate heap space in order to use a polymorphic data structure.
Anybody who wants to see the advantages and tradeoffs in using polymorphic data structures with void * should get a copy of Dave Hanson's book C Interfaces and Implementations

Your given link, is partially true. Especially, when you are not dealing with objects (structs), or in general with types that aren't already allocated. Using native types like ints, doubles etc. and void-pointers (e.g. for a container) is nearly always an icky affair, because you have either the choice to cast the int (for a double this doesn't work) to a pointer or you need to allocate extra memory for the data type.
First choice is bad because it is not portable, 0s are maybe not allowed as a value and it simply feels bad. Second choice wastes memory and is indeed a (massive) slow down because of the extra allocations.
But in most cases you aren't dealing with native types, but with objects, better said with pointers to objects, which are already allocated, at least I do. I never needed a hash-table or a map for integers or doubles. And having different container implementations only for type safeness of pointers feels wrong to me, because every implementation will increase your binary size. So if you are only need a container to store your pointers, there is no slow down or memory waste in using void-pointers.
But note, this was all about container implementations, like btw the blog article you mentioned. In general there are many things you cannot accomplish without using void-pointers.

The linked-to post compares operations with void pointers to operations with C++ templates, and concludes that the templates are more efficient.  This is hardly a surprise, and the C++ code I've seen uses void pointers rarely or never.  It generally offers no advantage over other C++ facilities, and can be a gaping hole in the type system.
However, C does not have C++-style templates, and void pointers are necessary to implement functionality that has to be independent of data type.  
Therefore, when you're writing in C, and you need genericity, void pointers are the most efficient means of getting it (since they're the only means).  When you're writing in C++, there's better ways to do almost anything void pointers can accomplish, so don't use them.

I dunno, I have found void pointers to be pretty effective for accessing different levels of abstraction (ABCs). As a means of navigating interlinked classes at different levels of abstraction. Its so simple, its awesome. Like the formula for e or the golden ratio, there should be an occult that worships the void* its that great :)  
