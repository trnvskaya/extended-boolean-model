What is the difference between Early and Late Binding?
binding dynamic-binding static-binding
What is the difference between early and late binding?


Taken directly from http://word.mvps.org/fAQs/InterDev/EarlyvsLateBinding.htm

There are two ways to use Automation (or OLE Automation) to
  programmatically control another application.
Late binding uses CreateObject to create and instance of the
  application object, which you can then control. For example, to create
  a new instance of Excel using late binding:
 Dim oXL As Object
 Set oXL = CreateObject("Excel.Application")

On the other hand, to manipulate an existing instance of Excel (if
  Excel is already open) you would use GetObject (regardless whether
  you're using early or late binding):
 Dim oXL As Object
 Set oXL = GetObject(, "Excel.Application")

To use early binding, you first need to set a reference in your
  project to the application you want to manipulate. In the VB Editor of
  any Office application, or in VB itself, you do this by selecting
  Tools + References, and selecting the application you want from the
  list (e.g. âMicrosoft Excel 8.0 Object Libraryâ).
To create a new instance of Excel using early binding:
 Dim oXL As Excel.Application
 Set oXL = New Excel.Application

In either case, incidentally, you can first try to get an existing
  instance of Excel, and if that returns an error, you can create a new
  instance in your error handler.


In compiled languages, the difference is stark.
Java:
//early binding:
public create_a_foo(*args) {
 return new Foo(args)
}
my_foo = create_a_foo();

//late binding:
public create_something(Class klass, *args) {
  klass.new_instance(args)
}
my_foo = create_something(Foo);

In the first example, the compiler can do all sorts of neat stuff at compile time.  In the second, you just have to hope that whoever uses the method does so responsibly.  (Of course, newer JVMs support the Class<? extends Foo> klass structure, which can greatly reduce this risk.)
Another benefit is that IDEs can hotlink to the class definition, since it's declared right there in the method.  The call to createsomething(Foo) might be _very far from the method definition, and if you're looking at the method definition, it might be nice to see the implementation.
The major advantage of late binding is that it makes things like inversion-of-control easier, as well as certain other uses of polymorphism and duck-typing (if your language supports such things).

In interpreted languages, the difference is a little more subtle.
Ruby:
# early binding:
def create_a_foo(*args)
  Foo.new(*args)
end
my_foo = create_a_foo

# late binding:
def create_something(klass, *args)
  klass.new(*args)
end
my_foo = create_something(Foo)

Because Ruby is (generally) not compiled, there isn't a compiler to do the nifty up-front stuff.  The growth of JRuby means that more Ruby is compiled these days, though, making it act more like Java, above.
The issue with IDEs still stands: a platform like Eclipse can look up class definitions if you hard-code them, but cannot if you leave them up to the caller.
Inversion-of-control is not terribly popular in Ruby, probably because of its extreme runtime flexibility, but Rails makes great use of late binding to reduce the amount of configuration necessary to get your application going.

The short answer is that early (or static) binding refers to compile time binding and late (or dynamic) binding refers to runtime binding (for example when you use reflection).

Late binding, or dynamic binding, is a computer programming mechanism in which the method being called upon an object is looked up by name at runtime.
With early binding, or static binding, the compilation phase fixes all types of variables and expressions. This is usually stored in the compiled program as an offset in a virtual method table ("v-table") and is very efficient. With late binding the compiler does not have enough information to verify the method even exists, let alone bind to its particular slot on the v-table. Instead the method is looked up by name at runtime.

Similar but more detailed answer from Herbert Schildt C++ book:-
Early binding refers to events that occur at compile time. In essence, early binding occurs when all information needed to call a function is known at compile time. (Put differently, early binding means that an object and a function call are bound during compilation.) Examples of early binding include normal function calls (including standard library functions), overloaded function calls, and overloaded operators. The main advantage to early binding is efficiency. Because all information necessary to call a function is determined at compile time, these types of function calls are very fast.
The opposite of early binding is late binding. Late binding refers
to function calls that are not resolved until run time. Virtual functions are used to achieve late binding. As you know, when access is via a base pointer or reference, the virtual function actually called is determined by the type of object pointed to by the pointer. Because in most cases this cannot be determined at compile time, the object and the function are not linked until run time. The main advantage to late binding is flexibility. Unlike early binding, late binding allows you to create programs that can respond to events occurring while the program executes without having to create a
large amount of "contingency code." Keep in mind that because a function call is not resolved until run time, late binding can make for somewhat slower execution times.
However today, fast computers have significantly reduced the execution times related to late binding.

public class child()
{    public void method1()
     {     System.out.println("child1");
     }
    public void method2()
     {     System.out.println("child2");
     }

}
public class teenager extends child()
{    public void method3()
     {      System.out.println("teenager3");
     }
}
public class adult extends teenager()
{     
    public void method1()
    {    System.out.println("adult1);
         super.method1();
     }
}


//In java
public static void main(String []args)
{    ((teenager)var).method1();
}

This will print out
adult1
child1

In early binding the compiler will have access to all of the methods 
in child and teenager
but in late binding (at runtime), it will check for methods that are overridden
at runtime.
Hence method1(from child -- early binding) will be overridden by the method1 from adult at runtime(late binding)
Then it will implement method1 from child since there is no method1 in method1 in teenager.
Note that if child did not have a method1 then the code in the main would not compile.
