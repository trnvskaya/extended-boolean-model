Free text search integrated with code coverage
language-agnostic search debugging code-coverage
Is there any tool which will allow me to perform a free text search over a system's code, but only over the code which was actually executed during a particular invocation?
To give a bit of background, when learning my way around a new system, I frequently find myself wanting to discover where some particular value came from, but searching the entire code base turns up far more matches than I can reasonably assess individually.
For what it's worth, I've wanted this in Perl and Java at one time or another, but I'd love to know if any languages have a system supporting this feature.


You can generally twist a code coverage tool's arm and get a report that shows the paths that have been executed during a given run.  This report should show the code itself, with the first few columns marked up according to the coverage tool's particular notation on whether a given path was executed.
You might be able to use this straight up, or you might have to preprocess it and either remove the code that was not executed, or add a new notation on each line that tells whether it was executed (most tools will only show path information at control points):
So from a coverage tool you might get a report like this:
T- if(sometest)
   {
x     somecode;
   }
   else
   {
-     someother_code;
   }

The notation T- indicates that the if statement only ever evaluated to true, and so only the first part of the code executed.  The later notation 'x' indicates that this line was executed.
You should be able to form a regex that matches only when the first column contains a T, F, or x so you can capture all the control statements executed and lines executed.
Sometimes you'll only get coverage information at each control point, which then requires you to parse the C file and mark the execute lines yourself.  Not as easy, but not impossible either.
Still, this sounds like an interesting question where the solution is probably more work than it's worth...
