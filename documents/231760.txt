What does a type followed by _t (underscore-t) represent?
c naming-conventions types
This seems like a simple question, but I can't find it with the Stack Overflow search or Google. What does a type followed by a _t mean? Such as
int_t anInt;

I see it a lot in C code meant to deal closely with hardwareâI can't help but think that they're related.


It means type.  size_t is the size type.

It's just a convention which means "type". It means nothing special to the compiler.

It's a convention used for naming data types, e.g with typedef:


typedef struct {
  char* model;
  int year;
...
} car_t;



If you're dealing with hardware interface code, the author of the code you're looking at might have defined int_t to be a specific size integer. The C standard doesn't assign a specific size to the int type (it depends on your compiler and target platform, potentially), and using a specific int_t type would avoid that portability problem.
This is a particularly important consideration for hardware interface code, which may be why you've first noticed the convention there.

As Douglas Mayle noted, it basically denotes a type name.   Consequently, you would be ill-advised to end variable or function names with '_t' since it could cause some confusion.  As well as size_t, the C89 standard defines wchar_t, off_t, ptrdiff_t, and probably some others I've forgotten.  The C99 standard defines a lot of extra types, such as uintptr_t, intmax_t, int8_t, uint_least16_t, uint_fast32_t, and so on.  These new types are formally defined in <stdint.h> but most often you will use <inttypes.h> which (unusually for standard C headers) includes <stdint.h>.  It (<inttypes.h>) also defines macros for use with the printf() and scanf().
As Matt Curtis noted, there is no significance to the compiler in the suffix; it is a human-oriented convention.
However, you should also note that POSIX defines a lot of extra type names ending in '_t', and reserves the suffix for the implementation.  That means that if you are working on POSIX-related systems, defining your own type names with the convention is ill-advised.  The system I work on has done it (for more than 20 years); we regularly get tripped up by systems defining types with the same name as we define.

It is a standard naming convention for data types, usually defined by typedefs.  A lot of C code that deals with hardware registers uses C99-defined standard names for signed and unsigned fixed-size data types.  As a convention, these names are in a standard header file (stdint.h), and end with _t.

The _t does not inherently have any special meaning.  But it has fallen into common use to add the _t suffix to typedef's.
You may be more familiar with common C practices for variable naming... This is similar to how it's common to stick a p at the front for a pointer, and to use an underscore in front of global variables (this is a bit less common), and to use the variable names i, j, and k for temporary loop variables.
In code where word-size and ordering is important, it's very common to use custom defined types  that are explicit, such as BYTE WORD (normally 16-bit) DWORD (32-bits).  
int_t is not so good, because the definition of int varies between platforms -- so whose int are you conforming to?  (Although, these days, most PC-centric development treats it as 32 bits, much stuff for non-PC development still treat int's as 16 bits).  

There were a few good explanations about the subject.  Just to add another reason for re-defining the types:
In many embedded projects, all types are redefined to correctly state the given sizing to the types and to improve portability across different platforms (i.e hardware types compilers).
Another reason will be to make your code portable across different OSs and to avoid collisions with existing types in the OS that you are integrating in your code.  For this, usually a unique (as possible) prefix is added.
Example:
typedef unsigned long dc_uint32_t;


The _t usually wraps an opaque type definition.
GCC merely add names that end with _t to the reserved namespace you may not use, to avoid conflicts with future versions of Standard C and POSIX (GNU C library manual). After some research, I finally found the correct reference inside the POSIX Standard (1003.1, Rationale (Informative)):

B.2.12 Data Types
The requirement that additional types defined in this section end in ââ_tââ was prompted by the
  problem of name space pollution. It is difficult to define a type (where that type is not one
  defined by IEEE Std 1003.1-2001) in one header file and use it in another without adding symbols
  to the name space of the program. To allow implementors to provide their own types, all
  conforming applications are required to avoid symbols ending in ââ_tââ, which permits the
  implementor to provide additional types. Because a major use of types is in the definition of
  structure members, which can (and in many cases must) be added to the structures defined in
  IEEE Std 1003.1-2001, the need for additional types is compelling.

In a nutshell, the Standard says that there are good chances of extending the Standard types' list, therefore the Standard restricts the _t namespace for its own use.
For instance, your program matchs POSIX 1003.1 Issues 6 and you defined a type foo_t. POSIX 1003.1 Issues 7 is eventually released with a new defined type foo_t. Your program does not match the new version, which might be a problem. Restricting the _t usage prevents from refactoring the code. Thus, if you aim to a POSIX compliancy, you should definitely avoid the _t as the Standard states it.
Side note: personally, I try to stick to POSIX because I think it gives good basics for clean programming. Moreover, I am pretty fond of Linux Coding Style (chapter 5) guidelines. There are some good reasons for why not using typedef. Hope this help!
