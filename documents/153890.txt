Printing leading 0's in C?
c printf
I'm trying to find a good way to print leading 0's, such as 01001 for a zipcode.  While the number would be stored as 1001, what is a good way to do it?
I thought of using either case statements/if then to figure out how many digits the number is and then convert it to an char array with extra 0's for printing but I can't help but think there may be a way to do this with the printf format syntax that is eluding me.  


printf("%05d", zipCode);



printf allows various formatting options.
ex:
printf("leading zeros %05d", 123);


You place a zero before the minimum field width:
printf("%05d",zipcode);


If you are on a *NIX Machine:
man 3 printf

This will show a manual page, similar to:

0      The value should be zero padded.  For d, i, o, u, x, X, a, A, e,
                E, f, F, g, and G conversions, the converted value is padded  on
                the  left  with  zeros rather than blanks.  If the 0 and - flags
                both appear, the 0 flag is ignored.  If  a  precision  is  given
                with  a numeric conversion (d, i, o, u, x, and X), the 0 flag is
                ignored.  For other conversions, the behavior is undefined.

Even though the question is for C, this page may be of aid.

sprintf(mystring, "%05d", myInt);

Here, "05" says "use 5 digits with leading zeros".

The correct solution is :  Store the Zipcode in the database as a STRING.  Despite the fact that it may look like a number, it isn't.  It's a code, where each part has meaning.  
A number is a thing you do arithmetic on. A zipcode is not that.

Zipcode is a highly localised field, many countries have characters in their postcodes, e.g., UK, Canada. Therefore in this example you should use a string / varchar field to store it if at any point you would be shipping or getting users/customers/clients/etc from other countries.
However in the general case you should use the recommended answer (printf("%05d", number);).

You will save yourself a heap of trouble (long term) if you store a zip code as a character string, which it is, rather than a number, which it is not.

More flexible.. 
Here's an example printing rows of right-justified numbers with fixed widths, and space-padding.
//---- Header
std::string getFmt ( int wid, long val )
{  
  char buf[64];
  sprintf ( buf, "% *ld", wid, val );
  return buf;
}
#define FMT (getFmt(8,x).c_str())

//---- Put to use
printf ( "      COUNT     USED     FREE\n" );
printf ( "A: %s %s %s\n", FMT(C[0]), FMT(U[0]), FMT(F[0]) );
printf ( "B: %s %s %s\n", FMT(C[1]), FMT(U[1]), FMT(F[1]) );
printf ( "C: %s %s %s\n", FMT(C[2]), FMT(U[2]), FMT(F[2]) );

//-------- Output
      COUNT     USED     FREE
A:      354   148523     3283
B: 54138259 12392759   200391
C:    91239     3281    61423

The function and macro are designed so the printfs are more readable.

If you need to store the zipcode in a character array zipcode[] , you can use this:
snprintf( zipcode, 6, "%05.5d", atoi(zipcode));

