Best way to format if statement with multiple conditions
language-agnostic if-statement
If you want to some code to execute based on two or more conditions which is the best way to format that if statement ?
first example:-
if(ConditionOne && ConditionTwo && ConditionThree)
{
   Code to execute
}

Second example:-
if(ConditionOne)
{
   if(ConditionTwo )
   {
     if(ConditionThree)
     {
       Code to execute
     }
   }
}

which is easiest to understand and read bearing in mind that each condition may be a long function name or something.


The first one is easier, because, if you read it left to right you get:
"If something AND somethingelse AND somethingelse THEN" , which is an easy to understand sentence. The second example reads "If something THEN if somethingelse THEN if something else THEN", which is clumsy.
Also, consider if you wanted to use some ORs in your clause - how would you do that in the second style?

Other answers explain why the first option is normally the best. But if you have multiple conditions, consider creating a separate function (or property) doing the condition checks in option 1. This makes the code much easier to read, at least when you use good method names.
if(MyChecksAreOk()) { Code to execute }

...

private bool MyChecksAreOk()
{ 
    return ConditionOne && ConditionTwo && ConditionThree;
}

It the conditions only rely on local scope variables, you could make the new function static and pass in everything you need. If there is a mix, pass in the local stuff.

I prefer Option A
bool a, b, c;

if( a && b && c )
{
   //This is neat & readable
}

If you do have particularly long variables/method conditions you can just line break them
if( VeryLongConditionMethod(a) &&
    VeryLongConditionMethod(b) &&
    VeryLongConditionMethod(c))
{
   //This is still readable
}

If they're even more complicated, then I'd consider doing the condition methods seperately outside the if statment
bool aa = FirstVeryLongConditionMethod(a) && SecondVeryLongConditionMethod(a);
bool bb = FirstVeryLongConditionMethod(b) && SecondVeryLongConditionMethod(b);
bool cc = FirstVeryLongConditionMethod(c) && SecondVeryLongConditionMethod(c);

if( aa && bb && cc)
{
   //This is again neat & readable
   //although you probably need to sanity check your method names ;)
}

IMHO The only reason for option 'B' would be if you have seperate else functions to run for each condition.
e.g.
if( a )
{
    if( b )
    {
    }
    else
    {
        //Do Something Else B
    }
}
else
{
   //Do Something Else A
}


The first example is more "easy to read". 
Actually, in my opinion you should only use the second one whenever you have to add some "else logic", but for a simple Conditional, use the first flavor. If you are worried about the long of the condition you always can use the next syntax:
if(ConditionOneThatIsTooLongAndProbablyWillUseAlmostOneLine
                 && ConditionTwoThatIsLongAsWell
                 && ConditionThreeThatAlsoIsLong) { 
     //Code to execute 
}

Good Luck!

The second one is a classic example of the Arrow Anti-pattern So I'd avoid it...
If your conditions are too long extract them into methods/properties.

The question was asked and has, so far, been answered as though the decision should be made purely on "syntactic" grounds. 
I would say that the right answer of how you lay-out a number of conditions within an if, ought to depend on "semantics" too. So conditions should be broken up and grouped according to what things go together "conceptually".
If two tests are really two sides of the same coin eg. if (x>0) && (x<=100) then put them together on the same line. If another condition is conceptually far more distant eg.  user.hasPermission(Admin()) then put it on it's own line
Eg.
if user.hasPermission(Admin()) {
   if (x >= 0) && (x < 100) {
      // do something
   }
}


In Perl you could do this:
{
  ( VeryLongCondition_1 ) or last;
  ( VeryLongCondition_2 ) or last;
  ( VeryLongCondition_3 ) or last;
  ( VeryLongCondition_4 ) or last;
  ( VeryLongCondition_5 ) or last;
  ( VeryLongCondition_6 ) or last;

  # Guarded code goes here
}

If any of the conditions fail it will just continue on, after the block. If you are defining any variables that you want to keep around after the block, you will need to define them before the block.

I believe switch...case statement is the best way to write tidy code under this circumstance, if the programming language supports it.
switch (//variable or Boolean) {
  case //Condition A:
  case //Condition B:
  case //Condition C:
    //Code to execute;
}


When condition is really complex I use the following style (PHP real life example):
if( $format_bool &&
    (
        ( isset( $column_info['native_type'] )
            && stripos( $column_info['native_type'], 'bool' ) !== false
        )
        || ( isset( $column_info['driver:decl_type'] )
            && stripos( $column_info['driver:decl_type'], 'bool' ) !== false
        )
        || ( isset( $column_info['pdo_type'] )
            && $column_info['pdo_type'] == PDO::PARAM_BOOL
        )
    )
)

I believe it's more nice and readable than nesting multiple levels of if(). And in some cases like this you simply can't break complex condition into pieces because otherwise you would have to repeat the same statements in if() {...} block many times.
I also believe that adding some "air" into code is always a good idea. It improves readability greatly.

I guess in C you can't just write:
if ( variable = (1 || 2 || 3) ) {
    do stuff;
}

Or is it maybe better to use a switch statement?

Functions like any() and all() can be very handy in making long conditions easier to read.
Your language might have them built-in (e.g. Python), or they might be available through a third-party library (e.g. Underscore.js in JavaScript).
An example in Python might look like this:
if any([a > b and a < c,
        a > c and random_factor()]):
    do_something()

or, more real-life though still quite far-fetched:
should_end_game = any([
    character.is_dead,
    timeout and timeout.exceeded,
]) or all([
    map.explored,
    len(character.artefacts.difference(available_artefacts)) == 0,
])

if should_end_game:
    end_game()

(In the last example the decision to chain any() and all() with or, instead of having all() as just another item in the any() list, is more or less arbitraryâsame behavior, possibly better readability.)
Depending on implementation in your language or library these functions might be more expensive performance-wise compared to raw conditionals, so if performance is critical and you have a lot of condition evaluations then consult the docs and profile.
