How do you disable browser Autocomplete on web form field / input tag?
html autocomplete
How do you disable autocomplete in the major browsers for a specific input (or form field)?


Firefox 30 ignores autocomplete="off" for passwords, opting to prompt the user instead whether the password should be stored on the client. Note the following commentary from May 5, 2014:


The password manager always prompts if it wants to save a password. Passwords are not saved without permission from the user.
We are the third browser to implement this change, after IE and Chrome.


According to Mozilla developer documentation the form element attribute autocomplete prevents form data from being cached in older browsers.
<input type="text" name="foo" autocomplete="off" />


<form autocomplete="off" ...
was a none standard way to do this (I think mozilla and IE still support it) but messing with the users expectations is normally a bad idea.  
If the user enters their credit card details into a form and then let's someone else use that browser it's not your concern :)
Use a non-standard name and id for the fields, so rather than "name" have "name_". Browsers will then not see it as being the name field. The best part about it is that you can do this to some but not all fields and it will autocomplete some but not all fields.
<form name="form1" id="form1" method="post" 
      autocomplete="off" action="http://www.example.com/form.cgi">

This will work in IE and FF, the downside is that it is not XHTML standard.

Just set autocomplete="off". There is a very good reason for doing this: You want to provide your own autocomplete functionality!

On a related, or actually, on the completely opposite note - if you're the user of the aforementioned form and want to re-enable the autocomplete functionality, use the 'remember password' bookmarklet from this bookmarklets page. It removes all 'autocomplete="off"' attributes from all forms on the page. Keep fighting the good fight!

Why would you make your user's life less convenient?
"Passwords / credit card data / etc. should not be saved" is a bad argument: with autocomplete on, browsers in Mac OS X store such values in an encrypted database with per-application permissions. Conversely, what's the realistic effect of autocomplete=off? The user is going to write it in an unencrypted text file, or better yet, on a post-it note attached to the screen.
Good thing there's bookmarklets like the one Antti mentioned, and patches to make the engine ignore the attribute altogether.
Seriously, I urge you to reconsider using this attribute. It does not benefit anyone.

We did actually use sasb's idea for one site. It was a medical software web app to run a doctor's office. However, many of our clients were surgeons who used lots of different workstations, including semi-public terminals. So, they wanted to make sure that a doctor who doesn't understand the implication of auto-saved passwords or isn't paying attention can't accidentally leave their login info easily accessible. Of course, this was before the idea of private browsing that is starting to be featured in IE8, FF3.1, etc. Even so, many physicians are forced to use old school browsers in hospitals with IT that won't change.
So, we had the login page generate random field names that would only work for that post. Yes, it's less convenient, but it's just hitting the user over the head about not storing login information on public terminals.

In addition to autocomplete=off, you could also have your form fields names be randomized by the code that generates the page, perhaps by adding some session-specific string to the end of the names.  When the form is submitted, you can strip that part off before processing them on the server side. This would prevent the web browser from finding context for your field and also might help prevent XSRF attacks because an attacker wouldn't be able to guess the field names for a form submission.

As others have said, the answer is autocomplete="off"
However I think it's worth stating why it's a good idea to use this in certain cases as some answers to this and duplicate questions have suggested it's better not to turn if off.
Stopping browsers storing credit card numbers shouldn't be left to users. Too many users won't even realise it's a problem.
It's particularly important to turn it off on fields for credit card security codes. As this page states

"Never store the security code ... its value depends on the presumption that the only way to supply it is to read it from the physical credit card, proving that the person supplying it actually holds the card."

The problem is, if it's a public computer (cyber cafe, library etc) it's then easy for other users to steal your card details, and even on your own machine a malicious website could steal autocomplete data.

In order to avoid the invalid XHTML you can set this attribute using javascript. Example using jQuery:
<input type="text" class="noAutoComplete" ... />

$(function() {
    $('.noAutoComplete').attr('autocomplete', 'off');
});

The problem is that users without javascript will do get the autocomplete functionality.

Adding the 
autocomplete="off" 
to the form tag will disable the browser autocomplete (what was previously typed into that field) from all input fields within that particular form.
Tested on:

Firefox 3.5, 4 BETA 
Internet Explorer 8 
Chrome


I think autocomplete=off is supported in HTML 5.
Ask yourself why you want to do this though - it may make sense in some situations but don't do it just for the sake of doing it.
It's less convenient for users and not even a security issue in OS X (mentioned by Soren below). If you're worried about people having their passwords stolen remotely - a keystroke logger could still do it even though your app uses autcomplete=off.
As a user who chooses to have a browser remember (most of) my information, I'd find it annoying if your site didn't remember mine.

I'd have to beg to differ with those answers that say to avoid disabling auto-complete.
The first thing to bring up is that auto-complete not being explicitly disabled on login form fields is a PCI-DSS fail. In addition, if a users' local machine is compromised then any autocomplete data can be trivially obtained by an attacker due to it being stored in the clear.
There is certainly an argument for usability, however there's a very fine balance when it comes to which form fields should have autocomplete disabled and which should not.

You may use in input.
For example;
<input type=text name="test" autocomplete="off" />


try these too if just autocomplete="off" doesn't work:
autocorrect="off" autocapitalize="off" autocomplete="off"


Three options:
First: 
<input type='text' autocomplete='off' />

Second: 
<form action='' autocomplete='off'>

Third (javascript code): 
$('input').attr('autocomplete', 'off');


None of the solutions worked for me in this conversation. 
I finally figured out a pure HTML solution that requires no Javascript, works in modern browsers (except IE; there had to at least 1 catch, right?), and does not require you to disable autocomplete for the entire form.
Simply turn off autocomplete on the form and then turn it ON for any input you wish it to work within the form. For example:
<form autocomplete="off">
    <!-- these inputs will not allow autocomplete and chrome 
         won't highlight them yellow! -->
    <input name="username"  />
    <input name="password" type="password" />
    <!-- this field will allow autocomplete to work even 
         though we've disabled it on the form -->
    <input name="another_field" autocomplete="on" />
</form>


Most of the major browsers and password managers (correctly, IMHO) now ignore autocomplete=off. 
Why? Many banks and other "high security" websites added autocomplete=off to their login pages "for security purposes" but this actually decreases security since it causes people to change the passwords on these high security sites to be easy to remember (and thus crack) since autocomplete was broken. 
Long ago most password managers started ignoring autocomplete=off, and now the browsers are starting to do the same for username/password inputs only.
Unfortunately bugs in the autocomplete implementations insert username and/or password info  into inappropriate form fields, causing form validation errors, or worse yet, accidentally inserting usernames into fields that were intentionally left blank by the user.
What's a web developer to do?

If you can keep all password fields on a page by themselves, that's a great start as it seems that the presence of a password field is the main trigger for user/pass autocomplete to kick in. Otherwise, read the tips below.
Safari notices that there are 2 password fields and disables autocomplete in this case, assuming it must be a change password form, not a login form. So just be sure to use 2 password fields (new and confirm new) for any forms where you allow 
Chrome 34 unfortunately will try to autofill fields with user/pass whenever it sees a password field. This is quite a bad bug that hopefully they will change to the Safari behavior. However, adding this to the top of your form seems to disable the password autofilling:
<input type="text" style="display:none">
<input type="password" style="display:none">


I haven't yet investigated IE or Firefox thoroughly but will be happy to update the answer if others have info in the comments.

Sometimes even autocomplete=off would not prevent to fill in credentials into wrong fields, but not user or nickname field. 
This workaround is in addition to apinstein's post about browser behavior.
fix browser autofill in: readonly and set writeble on focus (click and tab)
 <input type="password" readonly  
     onfocus="this.removeAttribute('readonly');"/>

Because, Browser auto fills credentials to wrong text field!?
I notice this strange behavior on Chrome and Safari, when there are password fields in the same form. I guess, the browser looks for a password field to insert your saved credentials. Then it autofills (just guessing due to observation) the nearest textlike-input field, that appears prior the password field in DOM. As the browser is the last instance and you can not control it, 
This readonly-fix above worked for me.

I've been trying endless solutions, and then I found this:
Instead of autocomplete="off" just simply use autocomplete="false"
As simple as that, and it works like a charm in Google Chrome as well!

This is a security issue that browsers ignores now. Browsers identifies and stores content using input names, even if developpers consider the information is sensitive and should not be stored. Making an input name different between 2 requests will solve the problem (but will still be saved in browser's cache and will also increase browser's cache). Ask the user to activate or deactivate options in its browser's settings is not a good solution. The issue can be fixed in the backend.
Here's my fix. An approach that I have implemented in my framework. All  autocomplete elements are generated with an hidden input like this :
<? $r = rmd5(rand().mocrotime(TRUE)); ?>
<form method="POST" action="./">
    <input type="text" name="<? echo $r; ?>" />
    <input type="hidden" name="__autocomplete_fix_<? echo $r; ?>" value="username" />
    <input type="submit" name="submit" value="submit" />
</form>

Server then process post variables like this :
foreach ($_POST as $key => $val)
{
    if(preg_match('#^__autocomplete_fix_#', $key) === 1){
        $n = substr($key, 19);
        if(isset($_POST[$n]))$_POST[$val] = $_POST[$n];
    }
}

The value can be accessed as usual
var_dump($_POST['username']);

And the browser won't be able to suggest information from previous request or from previous users.
All works like a charm, even if browsers updates, wants to ignore autocomplete or not. That has been the best way to fix the issue for me.

None of the hacks mentioned here worked for me in Chrome.
There's a discussion of the issue here: https://code.google.com/p/chromium/issues/detail?id=468153#c41
Adding this inside a <form> works (at least for now):
<div style="display: none;">
    <input type="text" id="PreventChromeAutocomplete" name="PreventChromeAutocomplete" autocomplete="address-level4" />
</div>


I know this is an old post, but it could be important to know that Firefox (I think only firefox) uses a value called ismxfilled that basically forces autocomplete.
ismxfilled="0" for OFF 
or 
ismxfilled="1" for ON

Adding autocomplete="off" is not gonna cut it.
Change input type attribute to type="search".
Google doesn't apply auto-fill to inputs with a type of search.

Safari does not change its mind about autocomplete if you set autocomplete="off" dynamically from javascript. However it would respect if you do that on per-field basis.
$(':input', $formElement).attr('autocomplete', 'off');


<script language="javascript" type="text/javascript">
    $(document).ready(function () {
        try {
            $("input[type='text']").each(function(){
                           $(this).attr("autocomplete","off");
                        });
        }
        catch (e)
        { }
    });

</script>


Chrome is planning to support this. 
For now the best suggestion is to use an input type that is rarely autocompleted. 
chrome discussion
<input type='search' name="whatever" />

to be compatible with firefox, use normal autocomplete='off'
<input type='search' name="whatever" autocomplete='off' />


You can disable autocomplete if you remove the form tag, the same was done by my bank and I was wondering how they did this. It even remove the value that was already remembered by the browser after you remove the tag.

This is what we called autocomplete of a textbox.

We can disable autocomplete of a Textbox in 2 ways-

By Browser Label
By Code
To disable in browser go to the setting



Go to advance setting and uncheck the checkbox and then Restore. 
If you want to disable in coding label you can do as follow-
Using AutoCompleteType="Disabled":
<asp:TextBox runat="server" ID="txt_userid" AutoCompleteType="Disabled"></asp:TextBox>  

By Setting Form autocomplete="off":
<asp:TextBox runat="server" ID="txt_userid" autocomplete="off"></asp:TextBox> 

By Setting Form autocomplete="off":
<form id="form1" runat="server" autocomplete="off">  
    //your content
</form>  

By using code in .cs page
protected void Page_Load(object sender, EventArgs e)  
    {  
    if(!Page.IsPostBack)  
    {  


        txt_userid.Attributes.Add("autocomplete", "off");  

    }  
}  

By Using Jquery
head runat="server">  
<title></title>  
<script src="Scripts/jquery-1.6.4.min.js"></script>  
<script type="text/javascript">  
    $(document).ready(function () {  
        $('#txt_userid').attr('autocomplete', 'off');  

    });  

</script>  


A little late to the game...but I just ran into this problem and tried several failures, but this one works for me found on MDN

In some case, the browser will keep suggesting autocompletion values
  even if the autocomplete attribute is set to off. This unexpected
  behavior can be quite puzzling for developers. The trick to really
  force the no-completion is to assign a random string to the attribute
  like so :

autocomplete="nope"


I can't believe this is still an issue so long after it's been reported. The above solutions didn't work for me, as safari seemed to know when the element was not displayed or off-screen, however the following did work for me:
<div style="height:0px; overflow:hidden; ">
  Username <input type="text" name="fake_safari_username" >
  Password <input type="password" name="fake_safari_password">
</div>

Hope that's useful for somebody!

If your issue is having a password field being auto-completed, then you may find this useful...
We had this issue in several areas of our site where the business wanted to re-query the user for their username and password and specifically did not want the password autofill to work for contractual reasons.  We found that the easiest way to do this is to put in a fake password field for the browser to find and fill while the real password field remains untouched.
<!-- This is a fake password input to defeat the browser's autofill behavior -->
<input type="password" id="txtPassword" style="display:none;" />
<!-- This is the real password input -->
<input type="password" id="txtThisIsTheRealPassword" />

Note that in Firefox and IE, it was simply enough to put any input of type password before the actual one but Chrome saw through that and forced me to actually name the fake password input (by giving it an obvious password id) to get it to "bite".  I used a class to implement the style instead of using an embedded style so try that if the above doesn't work for some reason.

You can simply put the autocomplete="off" in the HTML fields like following code.
<input type="text" name="" value="" autocomplete="off" />


So here is it (:
<input oninput="turnOnPasswordStyle()" id="inputpassword" type="text">

function turnOnPasswordStyle(){
        $('#inputpassword').attr('type', "password");
}


The answer dsuess posted with the readonly was very clever and worked. But as I am using boostrap, the readonly input field was - until focused - marked with grey background. While the document loads, you can trick the browser by simply locking and unlocking the input.
So I had an idea to implement this into jQuery solution:

    jQuery(document).ready(function () {
        $("input").attr('readonly', true);
        $("input").removeAttr('readonly');
   });



My problem was mostly autofill with Chrome, but I think this is probably more problematic than autocomplete.
Trick : using a timer to reset form and set password fields to blank. The 100ms duration seems to be minimal for it to work.
$(document).ready(function() {
    setTimeout(function() {
        var $form = $('#formId');
        $form[0].reset();
        $form.find('INPUT[type=password]').val('');
    }, 100);
});


I use the following jQuery snippet:
// Prevent input autocomplete
$.fn.preventAutocomplete = function() {
    this.each(function () {
        var $el = $(this);
        $el
            .clone(false, false)
            .insertBefore($el)
            .prop('id', '')
            .hide()
        ;
    });
};

And than just $('#login-form input').preventAutocomplete();
