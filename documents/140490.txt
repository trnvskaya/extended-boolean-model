Base constructor in C# - Which gets called first?
c# .net asp.net
Which gets called first - the base constructor or "other stuff here"?
public class MyExceptionClass : Exception
{
    public MyExceptionClass(string message, string extrainfo) : base(message)
    {
        //other stuff here
    }
}



I'd say base
EDIT see:
http://www.c-sharpcorner.com/UploadFile/rajeshvs/ConsNDestructorsInCS11122005010300AM/ConsNDestructorsInCS.aspx
there it says:
using System;
class Base
{

public Base()
{
    Console.WriteLine("BASE 1");
}
public Base(int x)
{
    Console.WriteLine("BASE 2");
}
}

class Derived : Base
{
public Derived():base(10)
{
    Console.WriteLine("DERIVED CLASS");
}
}

class MyClient
{
public static void Main()
{
    Derived d1 = new Derived();
}
}


This program outputs 
BASE2 
DERIVED CLASS


The base constructor will be called first.
try it:
public class MyBase
{
  public MyBase()
  {
    Console.WriteLine("MyBase");
  }
}

public class MyDerived : MyBase
{
  public MyDerived():base()
  {
    Console.WriteLine("MyDerived");
  }
}


http://www.devhood.com/tutorials/tutorial_details.aspx?tutorial_id=777
Base Constructor gets called first.

The Exception Constructor will be called, then your Child class constructor will be called.
Simple OO principle
Have a look here
http://www.dotnet-news.com/lien.aspx?ID=35151

Actually, the derived class constructor is executed first, but the C# compiler inserts a call to the base class constructor as first statement of the derived constructor.
So: the derived is executed first, but it "looks like" the base was executed first.

Base class constructors get called before derived class constructors, but derived class initializers get called before base class initializers. E.g. in the following code:
public class BaseClass {

    private string sentenceOne = null;  // A

    public BaseClass() {
    	sentenceOne = "The quick brown fox";  // B
    }
}

public class SubClass : BaseClass {

    private string sentenceTwo = null; // C

    public SubClass() {
    	sentenceTwo = "jumps over the lazy dog"; // D
    }
}

Order of execution is: C, A, B, D.
Check out these 2 msdn articles:

Why do initializers run in the opposite order as constructors? Part One
Why do initializers run in the opposite order as constructors? Part Two


The 'bass' constructor :)

The base constructor will be called first, otherwise, in cases where your "other stuff" must make use of member variables initialized by your base constructor, you'll get compile time errors because your class members will not have been initialized yet. 

base(?) is called before any work is done in the child constructor.
This is true, even if you leave off the :base() (in which case, the 0-parameter base constructor is called.)
It works similar to java,
public Child()
{
   super(); // this line is always the first line in a child constructor even if you don't put it there! ***
}

*** Exception: I could put in super(1,2,3) instead.  But if I don't put a call to super in explicitly, super() is called.

As others have said, the base constructor gets called first. However, constructors are not really the first thing that happens.
Let's say you have classes like this:
class A {}

class B : A {}

class C : B {}

First, field initializers will be called in order of most-derived to least-derived classes. So first field initializers of C, then B, then A.
The constructors will then be called in the opposite order: First A's constructor, then B, then C.

Constructor calls are called (fired) from the bottom up, and executed from the top down. Thus, if you had Class C which inherits from Class B which inherits from Class A, when you create an instance of class C the constructor for C is called, which in turn calls the instructor for B, which again in turn calls the constructor for A. Now the constructor for A is executed, then the constructor for B is executed, then the constructor for C is executed.

Don't try to remember it, try to explain to yourself what has to happen. Imagine that you have base class named Animal and a derived class named Dog. The derived class adds some functionality to the base class. Therefore when the constructor of the derived class is executed the base class instance must be available (so that you can add new functionality to it). That's why the constructors are executed from the base to derived but destructors are executed in the opposite way - first the derived destructors and then base destructors. 
(This is simplified but it should help you to answer this question in the future without the need to actually memorizing this.)

Eric Lippert had an interesting post on the related issue of object initialization, which explains the reason for the ordering of constructors and field initializers:
Why Do Initializers Run In The Opposite Order As Constructors? Part One

Why Do Initializers Run In The Opposite Order As Constructors? Part Two
