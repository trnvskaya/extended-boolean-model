What's the difference between a "Data Service Layer" and a "Data Access Layer"?
data-access-layer
I remember reading that one abstracts the low level calls into a data agnostic framework (eg. ExecuteCommand methods etc), and the other usually contains business specific methods (eg. UpdateCustomer).
Is this correct?  Which is which?


To me this is a personal design decision on how you want to handle your project design.  At times data access and data service are one and the same.  For .NET and LINQ that is the case.
To me the data service layer is what actually does the call to the database.  The data access layer receives the objects and creates them or modify them for the data service layer to make the call to the database.
In my designs the Business Logic Layer manipulates the objects based on the business rules, then passes them to the data access layer which will format them to go into the database or the objects from the database, and the data service layer handles the actual database call.

I think in general the two terms are interchangeable, but could have more specific meanings depending on the context of your development environment. 
A Data Access Layer sits on the border between data and the application. The "data" is simply the diverse set of data sources used by the application. This can mean that substantial coding must be done in each application to pull data together from multiple sources. The code which creates the data views required will be redundant across some applications.
As the number of data sources grows and becomes more complex, it becomes necessary to isolate various tasks of data access to address details of data access, transformation, and integration. With well-designed data services, Business Services will be able to interact with data at a higher level of abstraction. The data logic that handles data access, integration, semantic resolution, transformation, and restructuring to address the data views and structures needed by applications is best encapsulated in the Data Services Layer. 
It is possible to break the Data Services Layer down even further into its constituent parts (i.e. data access, transformation, and integration). In such a case you might have a "Data Access Layer" that concerns itself with only retrieving data, and a "Data Service Layer" that retrieves its data through the Data Access Layer and combines and transforms the retrieved data into the various objects required by the Business Service Layer.

The Data Service Layer concept done in the WebSphere Commerce documentation is straightforward:

The data service layer (DSL) provides an abstraction layer for data access that is independent of the physical schema. 
  The purpose of the data service layer is to provide a consistent interface (called the data service facade) for accessing data, independent of the object-relational mapping framework

Currently in internet the DSL concept is mainly associated with the SOAs (Service Oriented Architectures) but not only. Here is mentioned in an example of N-tier applications.

Here's another perspective deep from the trenches!  A Data Access Layer is a software abstraction layer which hides the complexity / implementation of actually getting the data.  The applications asks the Data Access Layer (See DAO design pattern) to "get me this" or "update that" etc (indirection).  The Data Access Layer is responsible for performing implementation-specific operations, such as reading/updating various data sources, such as Oracle, MySQL, Cassandra, RabbitMQ, Redis, a simple file system, a cache, or even delegate to another Data Service Layer.  
If all this work happens inside a single machine and in the same application, the term Data Service Layer is equivalent to a Service Facade (indirection).  It is responsible for servicing and delegating application calls to the correct Data Access Layer.
Somewhat confusingly, in a distributed computing world, or Service Oriented Architecture, a Data Service Layer can actually be a web service that acts as a standalone application.  In this context, the Data Service Layer delegates received upstream application data requests to the correct Data Access Layer.    In this instance, web services are indirecting data access from applications - the application only needs to know what service to call to get the data, so as a rule-of-thumb, in distributed computing environments, this approach will reduces application complexity (and there are always be exceptional cases)
So just to be clear, the application uses a DSL and a DAL.  The DSL in the app should talk to a DAL in the same application.  DAL's have the choice of using a single datasource, or delegate to another web service. Web Service DSL can delegate the work to the DAL for that request.   Indeed, it's possible for a single web service request to use a number of data sources in order to respond to the data.
With all that said, from a pragmatic perspecive, it's only when systems become increasingly complex, should more attention be paid to architectural patterns.  It's good practice to do things right, but there's no point in unnecessarily gold-plating your work.  Remember YAGNI?   Well that fails to resonate come the time it's needed!
To conclude:  A famous aphorism of David Wheeler goes: "All problems in computer science can be solved by another level of indirection";[1] this is often deliberately mis-quoted with "abstraction layer" substituted for "level of indirection". Kevlin Henney's corollary to this is, "...except for the problem of too many layers of indirection."
