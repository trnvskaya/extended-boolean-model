What is a race condition?
multithreading concurrency terminology race-condition
When writing multi-threaded applications, one of the most common problems experienced are race conditions.  
My questions to the community are:
What is a race condition? How do you detect them? How do you handle them? Finally, how do you prevent them from occurring?


A race condition is a kind of bug, that happens only with certain temporal conditions.
Example:
Imagine you have two threads, A and B.
In Thread A:
if( object.a != 0 )
    object.avg = total / object.a

In Thread B:
object.a = 0

If thread A is preempted just after having check that object.a is not null, B will do a = 0, and when thread A will gain the processor, it will do a "divide by zero". 
This bug only happen when thread A is preempted just after the if statement, it's very rare, but it can happen.

A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data. 
Problems often occur when one thread does a "check-then-act" (e.g. "check" if the value is X, then "act" to do something that depends on the value being X) and another thread does something to the value in between the "check" and the "act". E.g:
if (x == 5) // The "Check"
{
   y = x * 2; // The "Act"

   // If another thread changed x in between "if (x == 5)" and "y = x * 2" above,
   // y will not be equal to 10.
}

The point being, y could be 10, or it could be anything, depending on whether another thread changed x in between the check and act. You have no real way of knowing.
In order to prevent race conditions from occurring, you would typically put a lock around the shared data to ensure only one thread can access the data at a time. This would mean something like this:
// Obtain lock for x
if (x == 5)
{
   y = x * 2; // Now, nothing can change x until the lock is released. 
              // Therefore y = 10
}
// release lock for x


A race condition is a situation on concurrent programming where two concurrent threads or processes and the resulting final state depends on who gets the resource first.

Race conditions occur in multi-threaded applications or multi-process systems.  A race condition, at its most basic, is anything that makes the assumption that two things not in the same thread or process will happen in a particular order, without taking steps to ensure that they do.  This happens commonly when two threads are passing messages by setting and checking member variables of a class both can access.  There's almost always a race condition when one thread calls sleep to give another thread time to finish a task (unless that sleep is in a loop, with some checking mechanism).
Tools for preventing race conditions are dependent on the language and OS, but some comon ones are mutexes, critical sections, and signals.  Mutexes are good when you want to make sure you're the only one doing something.  Signals are good when you want to make sure someone else has finished doing something.  Minimizing shared resources can also help prevent unexpected behaviors
Detecting race conditions can be difficult, but there are a couple signs.  Code which relies heavily on sleeps is prone to race conditions, so first check for calls to sleep in the affected code.  Adding particularly long sleeps can also be used for debugging to try and force a particular order of events.  This can be useful for reproducing the behavior, seeing if you can make it disappear by changing the timing of things, and for testing solutions put in place.  The sleeps should be removed after debugging.
The signature sign that one has a race condition though, is if there's an issue that only occurs intermittently on some machines.  Common bugs would be crashes and deadlocks.  With logging, you should be able to find the affected area and work back from there.

A sort-of-canonical definition is "when two threads access the same location in memory at the same time, and at least one of the accesses is a write." In the situation the "reader" thread may get the old value or the new value, depending on which thread "wins the race." This is not always a bug—in fact, some really hairy low-level algorithms do this on purpose—but it should generally be avoided. @Steve Gury give's a good example of when it might be a problem.

A "race condition" exists when multithreaded (or otherwise parallel) code that would access a shared resource could do so in such a way as to cause unexpected results.
Take this example:
for ( int i = 0; i < 10000000; i++ )
{
   x = x + 1; 
}

If you had 5 threads executing this code at once, the value of x WOULD NOT end up being 50,000,000.  It would in fact vary with each run.
This is because, in order for each thread to increment the value of x, they have to do the following: (simplified, obviously)

Retrieve the value of x
Add 1 to this value
Store this value to x

Any thread can be at any step in this process at any time, and they can step on each other when a shared resource is involved.  The state of x can be changed by another thread during the time between x is being read and when it is written back.
Let's say a thread retrieves the value of x, but hasn't stored it yet.  Another thread can also retrieve the same value of x (because no thread has changed it yet) and then they would both be storing the same value (x+1) back in x!
Example:

Thread 1: reads x, value is 7
Thread 1: add 1 to x, value is now 8
Thread 2: reads x, value is 7
Thread 1: stores 8 in x
Thread 2: adds 1 to x, value is now 8
Thread 2: stores 8 in x

Race conditions can be avoided by employing some sort of locking mechanism before the code that accesses the shared resource:
for ( int i = 0; i < 10000000; i++ )
{
   //lock x
   x = x + 1; 
   //unlock x
}

Here, the answer comes out as 50,000,000 every time.
For more on locking, search for: mutex, semaphore, critical section, shared resource.

Here is the classical Bank Account Balance example which will help newbies to understand Threads in Java easily w.r.t. race conditions:
public class BankAccount {

/**
 * @param args
 */
int accountNumber;
double accountBalance;

public synchronized boolean Deposit(double amount){
    double newAccountBalance=0;
    if(amount<=0){
        return false;
    }
    else {
        newAccountBalance = accountBalance+amount;
        accountBalance=newAccountBalance;
        return true;
    }

}
public synchronized boolean Withdraw(double amount){
    double newAccountBalance=0;
    if(amount>accountBalance){
        return false;
    }
    else{
        newAccountBalance = accountBalance-amount;
        accountBalance=newAccountBalance;
        return true;
    }
}

public static void main(String[] args) {
    // TODO Auto-generated method stub
    BankAccount b = new BankAccount();
    b.accountBalance=2000;
    System.out.println(b.Withdraw(3000));

}


A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, but because of the nature of the device or system, the operations must be done in the proper sequence in order to be done correctly.
In computer memory or storage, a race condition may occur if commands to read and write a large amount of data are received at almost the same instant, and the machine attempts to overwrite some or all of the old data while that old data is still being read. The result may be one or more of the following: a computer crash, an "illegal operation," notification and shutdown of the program, errors reading the old data, or errors writing the new data.

Microsoft actually have published a really detailed article on this matter of race conditions and deadlocks. The most summarized abstract from it would be the title paragraph:

A race condition occurs when two threads access a shared variable at
  the same time. The first thread reads the variable, and the second
  thread reads the same value from the variable. Then the first thread
  and second thread perform their operations on the value, and they race
  to see which thread can write the value last to the shared variable.
  The value of the thread that writes its value last is preserved,
  because the thread is writing over the value that the previous thread
  wrote.


Try this basic example for better understanding of race condition:
    public class ThreadRaceCondition {

    /**
     * @param args
     * @throws InterruptedException
     */
    public static void main(String[] args) throws InterruptedException {
        Account myAccount = new Account(22222222);

        // Expected deposit: 250
        for (int i = 0; i < 50; i++) {
            Transaction t = new Transaction(myAccount,
                    Transaction.TransactionType.DEPOSIT, 5.00);
            t.start();
        }

        // Expected withdrawal: 50
        for (int i = 0; i < 50; i++) {
            Transaction t = new Transaction(myAccount,
                    Transaction.TransactionType.WITHDRAW, 1.00);
            t.start();

        }

        // Temporary sleep to ensure all threads are completed. Don't use in
        // realworld :-)
        Thread.sleep(1000);
        // Expected account balance is 200
        System.out.println("Final Account Balance: "
                + myAccount.getAccountBalance());

    }

}

class Transaction extends Thread {

    public static enum TransactionType {
        DEPOSIT(1), WITHDRAW(2);

        private int value;

        private TransactionType(int value) {
            this.value = value;
        }

        public int getValue() {
            return value;
        }
    };

    private TransactionType transactionType;
    private Account account;
    private double amount;

    /*
     * If transactionType == 1, deposit else if transactionType == 2 withdraw
     */
    public Transaction(Account account, TransactionType transactionType,
            double amount) {
        this.transactionType = transactionType;
        this.account = account;
        this.amount = amount;
    }

    public void run() {
        switch (this.transactionType) {
        case DEPOSIT:
            deposit();
            printBalance();
            break;
        case WITHDRAW:
            withdraw();
            printBalance();
            break;
        default:
            System.out.println("NOT A VALID TRANSACTION");
        }
        ;
    }

    public void deposit() {
        this.account.deposit(this.amount);
    }

    public void withdraw() {
        this.account.withdraw(amount);
    }

    public void printBalance() {
        System.out.println(Thread.currentThread().getName()
                + " : TransactionType: " + this.transactionType + ", Amount: "
                + this.amount);
        System.out.println("Account Balance: "
                + this.account.getAccountBalance());
    }
}

class Account {
    private int accountNumber;
    private double accountBalance;

    public int getAccountNumber() {
        return accountNumber;
    }

    public double getAccountBalance() {
        return accountBalance;
    }

    public Account(int accountNumber) {
        this.accountNumber = accountNumber;
    }

    // If this method is not synchronized, you will see race condition on
    // Remove syncronized keyword to see race condition
    public synchronized boolean deposit(double amount) {
        if (amount < 0) {
            return false;
        } else {
            accountBalance = accountBalance + amount;
            return true;
        }
    }

    // If this method is not synchronized, you will see race condition on
    // Remove syncronized keyword to see race condition
    public synchronized boolean withdraw(double amount) {
        if (amount > accountBalance) {
            return false;
        } else {
            accountBalance = accountBalance - amount;
            return true;
        }
    }
}


There is an important technical difference between race conditions and data races. Most answers seem to make the assumption that these terms are equivalent, but they are not. 
A data race occurs when 2 instructions access the same memory location, at least one of these accesses is a write and there is no happens before ordering among these accesses. Now what constitutes a happens before ordering is subject to a lot of debate, but in general ulock-lock pairs on the same lock variable and wait-signal pairs on the same condition variable induce a happens-before order. 
A race condition is a semantic error. It is a flaw that occurs in the timing or the ordering of events that leads to erroneous program behavior. 
Many race conditions can be (and in fact are) caused by data races, but this is not necessary. As a matter of fact, data races and race conditions are neither the necessary, nor the sufficient condition for one another. This blog post also explains the difference very well, with a simple bank transaction example. Here is another simple example that explains the difference.
Now that we nailed down the terminology, let us try to answer the original question.
Given that race conditions are semantic bugs, there is no general way of detecting them. This is because there is no way of having an automated oracle that can distinguish correct vs. incorrect program behavior in the general case. Race detection is an undecidable problem.
On the other hand, data races have a precise definition that does not necessarily relate to correctness, and therefore one can detect them. There are many flavors of data race detectors (static/dynamic data race detection, lockset-based data race detection, happens-before based data race detection, hybrid data race detection). A state of the art dynamic data race detector is ThreadSanitizer which works very well in practice.
Handling data races in general requires some programming discipline to induce happens-before edges between accesses to shared data (either during development, or once they are detected using the above mentioned tools). this can be done through locks, condition variables, semaphores, etc. However, one can also employ different programming paradigms like message passing (instead of shared memory) that avoid data races by construction.


What is a Race Condition?

You are planning to go to a movie at 5 pm. You inquire about the availability of the tickets at 4 pm. The representative says that they are available. You relax and reach the ticket window 5 minutes before the show. I'm sure you can guess what happens: it's a full house. The problem here was in the duration between the check and the action. You inquired at 4 and acted at 5. In the meantime, someone else grabbed the tickets. That's a race condition - specifically a "check-then-act" scenario of race conditions.

How do you detect them?

Religious code review, multi-threaded unit tests. There is no shortcut. There are few Eclipse plugin emerging on this, but nothing stable yet.

How do you handle and prevent them?

The best thing would be to create side-effect free and stateless functions, use immutables as much as possible. But that is not always possible. So using java.util.concurrent.atomic, concurrent data structures, proper synchronization, and actor based concurrency will help.
The best resource for concurrency is JCIP. You can also get some more details on above explanation here.

You don't always want to discard a race condition. If you have a flag which can be read and written by multiple threads, and this flag is set to 'done' by one thread so that other thread stop processing when flag is set to 'done', you don't want that "race condition" to be eliminated. In fact, this one can be referred to as a benign race condition. 
However, using a tool for detection of race condition, it will be spotted as a harmful race condition.
More details on race condition here, http://msdn.microsoft.com/en-us/magazine/cc546569.aspx. 

Ok thats 4 questions. one by one answer is as under....

What is a race condition?

It occurs when the output and/or result of the process is critically dependent on the sequence or timing of other events i.e. e.g. 2 signals are racing to change the output first.

How do you detect them? 

It leads to error which is difficult to localize.

How do you handle them? 

Use Semaphores
And finally,

How do you prevent them from occurring?

One way to avoid race condition is using locking mechanism for resources. but locking resources can lead to deadlocks. which has to be dealt with.


What is a race condition? How do you detect them? How do you prevent
  them from occurring? 

Number of answers in this thread find a comfort in categorizing the issue, i.e. in classifying race conditions into separate subclasses, like "check-then-act" or "read-update-write", or "data race vs. race condition" and so on.  
My point is that repeating the same things over and over may pacify a reader or even a writer him/herself, but it does not help the state of the art and answer the general and basic question: how to diagnose and explain a race condition automatically, i.e. without the presence of human error-prone in the process of the race condition diagnosis.  It is the human error-prone qualities what put the race conditions there in the first place.
Another point is that the presence of all this, often superficial,  classifications does not help the state of the art at all.  Simply see how quickly the number of the questions about race conditions is growing over time on Stack Overflow with a speed of about 1,000 new questions and answers every few month. Searching on "race condition" today would return you 12,364 posted questions.
Below you will find a solution that DOES help the state of the art.  It is completely automatic and it is not based of artificial subclassifications.
Java Language Specification (JLS) uses the term data race.  The formal definition of data race by the Java Language Specification (JLS) does not impose such limitations as some of the answers in this thread. 

"What is a race condition?"

If you study the definition of 'data race' by the JLS you will see that it exactly defines what program state is commonly understood by the term 'race condition'. âRace condition is a condition when multiple threads are accessing shared memory in undetermined order, and when at least one access is for âwriteâ i.e. modifying the memory contentâ.

"How do you detect them?" 

The solution for detecting all âdata racesâ or ârace conditionsâ in the context of multithreading exists and the problem is absolutely decidable by a proper dynamic analysis tool with 0% false positive result. The reasoning is explained further. The reference to one technology is offered here with the following disclaimer: the technology was build by our team at Thinking Software, Inc. and the tool is called Race Catcherâ¢

"How do you prevent them from occurring?"  

Cognitive reasoning of race conditions analysis has proven to be a difficult for humans task. Using specially built libraries is also requiring not making cognitive mistakes.
âIf debugging is the process of removing bugs, then programming must be the process of putting them in.â (Edsger W. Dijkstra)
We can not prevent them from occurring, but we can immediately identify them upon their very first manifestation, and prevent them from re-occurring, much like we can not prevent misspellings or syntax errors from their first manifestation.
Being able to identify misspellings or software syntax errors statically is defined by their static nature. They are manifested as soon as you typed them.  Race conditions have a dynamic nature and they manifest dynamically.
Having a proper tool that catches and automatically diagnoses them upon their very first occurence has the same effect on saving one's time and on the final result's reliability as you get from a built-in syntax checker that catches all manifested during one's writing spelling errors.

Further reasoning and explanations:

Race conditions are one of the most challenging issues in contemporary programming and are a primary cause of unstable, intermittent, and unreliable software behavior. They can not be properly diagnosed by traditional debuggers (see further) or by log files (see further) and the cognitive, 'between the ears' approach to solve the issues were proven to provide over 30% of improper fixes, even when the presence of race conditions was noticed.
For the point of reference, here is list of the main points of traditional disagreements.

Are data race and race condition, two different sets of conditions? Is one a subset of another? Are these the same conditions?
Is race detection an un-decidable problem? Is it even possible to find one using any tool at all?
Is the presence of context switching required for a race condition to occur?
Is it possible to âdebugâ a race condition using a debugger? Should one use logging to âdebugâ a race?
Can we label some race conditions as âbenignâ?
What technology is available to address detection of race conditions?


Re. question-1: 
  Separating ârace conditionâ and âdata raceâ is not done âby the bookâ and it does not address the real issue of eliminating the intermittent incorrectness in results and providing a higher level of software reliability.

The Java Language Specification (JLS) formally defines âdata race âusing 'happens-before-relatioships' between actions within a process. It in turn defines 'happens-before' via order of the actions and visibility of their result by the following ordered actions.
The disconnect between the proponents of defining âdata raceâ separately comes from the notion of what is "simultaneous" or "concurrent" access to a shared memory.  How simultaneous is "simultaneous"? (The answer is obviously not there since what we are trying to define is really the uncertainty of ordering). Is it that âread â modify- write backâ series of operations from two or more threads have to occur so simultaneously that before one writes back, the other one reads. Or is it sufficient to say that the 'simultaneously' means that one event can come before or after another, or on top of another in absolute time such that it would cause overlapping one threadâs âread-modify-writeâ events with another threadâs âread-modify-writeâ events or with another threadâs âreadâ event.
While defining the rules for correctly synchronized programs, JLS is using the terms âhappened beforeâ hb(x,y) â meaning âxâ must happen before âyâ and that the result of âxâ must be âvisibleâ to âyâ. The specification does not speak about that the hb(x,y) must refer to the operations of âread-modify- write backâ  components of âwriteâ, but speaks in general of any events that are intended to be ordered for the correct execution of the intended algorithm, no matter what reordering a particular JVMâs thread scheduler may decide to make.

Re. question-2: Properly built dynamic analysis tool will immediately pinpoint and automatically diagnose 'race conditions' (or data races). As mentioned above, a 'race condition' has to manifest itself (it has to happen) to be diagnosed by such tool, however the result will be immediate and 0% false positive.
Re. question-3: Context switching is not required for race condition to be experienced when more than one core is involved in running the process.
Re. question 4: Debuggers will not help you catch a race, since debugging environment debugs the debugging environment. The thread scheduler is presented there with completely different sets of threads and locks.

Using logging to debug a race and tracing backwards to understand the race is also simply impractical for any sufficiently complex multithreading application. Another point to make is that logging to a file will create additional synchronization, which will disappear as soon as the logging is disabled.

Re. question 5: The question of "Which race condition can be called âbenignâ and can be ignored?" is best answered here: "How to miscompile programs with âbenignâ data races". The point is that what one may see as âbenignâ can easily become very harmful as a result of different compiler optimizations.

The best approach to this question is âJust say No to âbenignâ racesâ as it is well said in the article âBenign data races: what could possibly go wrong?â

Re. question 6: What technology is available to address the issue?

Static analysis tools. The shortcomings:
a)  Traditionally accepted shortcomings of static analysis tools are their large rate of false positive diagnosis. The false positive results come from assumptions that specific states are possible, when in fact they are not, but the reasoning behind such understanding would be too complex.
b)  The other shortcoming of static analysis tools is in missing actual races. That is due to the fact that static analysis tools have to address unlimited combinations of states (âState explosionâ issue. See testing_vs_model_checking)
 Thus they are approaching the subject by studying subsets that they can chew on and as such are missing actual races. 
Dynamic analysis tools: 
(a) the traditional shortcoming is in large overhead prohibiting their use in production, however not all dynamic analysis tools are created equal. The tool that we have built after years of working on different  optimizations (see Race Catcherâ¢ above) provides overhead that is 100s of times smaller than some other dynamic analysis tools, and is actually usable in production.
(b) Good dynamic code analyzer provides 0% false positive results. This is because it pinpoints and analyzes races that have been actually manifested.
Disclaimer: the Race Catcherâ¢ technology was build by our team at Thinking Software, Inc.

Consider an operation which has to display the count as soon as the count gets incremented. ie., as soon as CounterThread increments the value DisplayThread needs to display the recently updated value.
int i = 0;

Output  
CounterThread -> i = 1  
DisplayThread -> i = 1  
CounterThread -> i = 2  
CounterThread -> i = 3  
CounterThread -> i = 4  
DisplayThread -> i = 4

Here CounterThread gets the lock frequently and updates the value before DisplayThread displays it. Here exists a Race condition. Race Condition can be solved by using Synchronzation
