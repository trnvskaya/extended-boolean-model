Python subprocess.call() fails when using pythonw.exe
python multithreading subprocess
I have some Python code that works correctly when I use python.exe to run it, but fails if I use pythonw.exe.

    def runStuff(commandLine):
        outputFileName = 'somefile.txt'
        outputFile = open(outputFileName, "w")

        try:
            result = subprocess.call(commandLine, shell=True, stdout=outputFile)
        except:
            print 'Exception thrown:', str(sys.exc_info()[1])

    myThread = threading.Thread(None, target=runStuff, commandLine=['whatever...'])
    myThread.start()

The message I get is:

    Exception thrown: [Error 6] The handle is invalid

However, if I don't specify the 'stdout' parameter, subprocess.call() starts okay.
I can see that pythonw.exe might be redirecting output itself, but I can't see why I'm blocked from specifying stdout for a new thread.


sys.stdin and sys.stdout handles are invalid because pythonw does not provide console support as it runs as a deamon, so default arguments of subprocess.call() are failing.
Deamon programs close stdin/stdout/stderr purposedly and use logging instead, so that you have to manage this yourself: I would suggest to use subprocess.PIPE.
If you really don't care about what the sub process says for errors and all, you could use os.devnull (I'm not really sure how portable it is?) but I wouldn't recommend that.

For the record, my code now looks like this:
def runStuff(commandLine):
    outputFileName = 'somefile.txt'
    outputFile = open(outputFileName, "w")

    if guiMode:
        result = subprocess.call(commandLine, shell=True, stdout=outputFile, stderr=subprocess.STDOUT)
    else:
        proc = subprocess.Popen(commandLine, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE)
        proc.stdin.close()
        proc.wait()
        result = proc.returncode
        outputFile.write(proc.stdout.read())

Note that, due to an apparent bug in the subprocess module, the call to Popen() has to specify a pipe for stdin as well, which we close immediately afterwards.

This is an old question, but the same problem happened with pyInstaller too. 
In the truth, this will happen with any framework that converts code in python for exe without console.
In my tests, I observed that if I use the flag "console=True" into my spec file (pyInstaller) the error no longer occurs. .
The solution was follow the tip of Piotr Lesnicki.
