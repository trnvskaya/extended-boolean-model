How do I allow assembly (unit testing one) to access internal properties of another assembly?
.net unit-testing
I would like my Core assembly to not expose a certain class and I would still like to be able to test it. How can I do that ?


InternalsVisibleTo attribute to the rescue!
Just add:  
[assembly:InternalsVisibleToAttribute("UnitTestAssemblyName")]

to your Core classes AssemblyInfo.cs file
See Friend Assemblies (C# Programming Guide) for best practices.

You can use reflection (as the MS Test items do), or you can declare the unit test assembly a friend of the core assembly.
The other option is to put the unit tests in the same assembly.

With InternalsVisible if your assemblies are strongly named you need to specify the public key (note: the full key not the public key token) for example...
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("BoardEx_BusinessObjects.Tests, 
  PublicKey=0024000004800000940000000602000000240000525341310004000001000100fb3a2d8 etc etc")]

and the following trick is really useful for getting the public key without resorting to the cmd line...
http://www.andrewconnell.com/blog/archive/2006/09/15/4587.aspx

I would suggest not going to such troubles ... if you really want to unit test your "internal" classes, just hide them away in a namespace that only your internal code would end up using.  Unless you're writing a framework on the scale of the .NET framework, you don't really need that level of hiding.

I put my unit tests in the same assembly as the code that it's testing.  This makes sense to me, because I think of "test yourself" as a feature of a class, along with things like "initialize yourself" and "describe yourself".
I've heard some objections to this approach, but few of them have been convincing.
It hurts performance Bah, I say!  Don't optimize without hard data!  Perhaps if you are planning your assemblies to be downloaded over slow links, then minimizing assembly size would be worthwhile.  
It's a security risk.  Only if you have secrets in your tests.  Don't do that.
Now, your situation is different from mine, so maybe it'll make sense for you, and maybe it won't.  You'll have to figure that out yourself.
Aside: In C#, I once tried putting my unit tests in a class named "Tests" that was nested inside the class that it was testing.  This made the correct organization of things obvious.  It also avoided the duplication of names that occurs when tests for the class "Foo" are in a class called "FooTests".  However, the unit testing frameworks that I had access to refused to accept tests that weren't marked "public".  This means that the class that you're testing can't be "private".  I can't think of any good reason to require tests to be "public", since no one really calls them as public methods - everything is through reflection.  If you ever write a unit testing framework for .Net, please consider allowing non-public tests, for my sake!
